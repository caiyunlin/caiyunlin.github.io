[
  
  {
    "title": "Docker 是如何运行的",
    "url": "/2022/04/docker-namespace/",
    "categories": "技术",
    "tags": "docker",
    "date": "2022-04-02 10:03:00 +0800",
    





    
    "snippet": "之前有篇博客介绍了 docker 的一些常用使用命令，这篇博客来详细研究一下 docker 是如何运行的。我们可以使用 docker exec 在这个容器(container)内来执行一个进程。或者说，在这个容器内，我们是 root，这里的容器是什么呢，在 linux 里面，容器实现的方法就是 namespace .什么是 namespace我们查询一下官方文档 https://docs.d...",
    "content": "之前有篇博客介绍了 docker 的一些常用使用命令，这篇博客来详细研究一下 docker 是如何运行的。我们可以使用 docker exec 在这个容器(container)内来执行一个进程。或者说，在这个容器内，我们是 root，这里的容器是什么呢，在 linux 里面，容器实现的方法就是 namespace .什么是 namespace我们查询一下官方文档 https://docs.docker.com/get-started/overview/#the-underlying-technology 里面提到  Docker is written in the Go programming language and takes advantage of several features of the Linux kernel to deliver its functionality. Docker uses a technology called namespaces to provide the isolated workspace called the container. When you run a container, Docker creates a set of namespaces for that container.  These namespaces provide a layer of isolation. Each aspect of a container runs in a separate namespace and its access is limited to that namespace.Docker 使用了一个叫 namespaces 的技术用来提供一个隔离的工作区，叫做 container.我们来做个试验宿主机： 用户 calvin 机器名 yicDocker : 用户 root 机器名 89e9c8fdb4e8查看用户 id在宿主机上，我们运行 id 会显示当前登录的 id 信息，比如下面calvin@yic:~$ iduid=1000(calvin) gid=1000(calvin) groups=1000(calvin),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(lxd),114(netdev),999(docker)calvin@yic:~$在 docker 里面执行 id 会显示如下信息# 运行一个 ubuntu docker ，打开共享目录docker run -v $PWD/shared_data:/opt/shared -it ubuntu /bin/bash# 查询id，我们会发现用户是 rootroot@89e9c8fdb4e8:/# iduid=0(root) gid=0(root) groups=0(root)root@89e9c8fdb4e8:/#文件测试在 docker 里创建一个文件，我们发现文件的拥有者是 rootroot@e5343d96c0d6:/# touch file root@89e9c8fdb4e8:/# ls -lah file-rw-r--r-- 1 root root 0 Apr 28 12:02 file我们回到宿主机看文件，你会发现文件的创建者是 calvin，但是如果用户是共享的那么就会是 root，下面用户 namespace 会提到calvin@yic:~/shared_data$ ls -lah file-rw-r--r--  1 calvin   calvin      0 Apr 28 12:05 file进程测试我们在 docker 里面运行 watch 命令，watch 会每隔2秒执行一次需要watch的指令root@e5343d96c0d6:/# watch -d \"ps ax\" Every 2.0s: ps ax                                                                   PID TTY      STAT   TIME COMMAND    1 pts/0    Ss     0:00 /bin/bash   14 pts/0    S+     0:00 watch -d ps ax  237 pts/0    S+     0:00 watch -d ps ax  238 pts/0    S+     0:00 sh -c ps ax  239 pts/0    R+     0:00 ps ax同时我们在宿主机执行 “ps ax | grep watch”，你会发现同样的右 watch -d ps ax 命令，这个其实就说明了 watch 命令也是运行在主机里面的。 他的 pid 和 docker 里面的 pid 不一样，这个就可以说明 docker container 不是 VM ，他和宿主机是共享了某些东西。但是肯定也是有隔离，因为 container 里面是无法感知到宿主机的进程的。calvin@yic:~/shared_data$ ps ax | grep watch   86 ?        S      0:00 [watchdogd]24450 pts/0    S+     0:00 watch -d ps ax24806 pts/0    S+     0:00 grep --color=auto watch我们在宿主机运行 pstree 会看到 watch 的 process 是被 containerd-shim -&gt; bash 启动的calvin@yic:~/shared_data$ pstreesystemd─┬─accounts-daemon───2*[{accounts-daemon}]        ├─2*[agetty]        ├─apache2───7*[apache2]        ├─atd        ├─containerd───11*[{containerd}]        ├─containerd-shim─┬─bash───watch        │                 └─12*[{containerd-shim}]        ├─cron        ├─dbus-daemon我们查一下 containerd 是什么， 官方文档 https://containerd.io/  containerd is available as a daemon for Linux and Windows. It manages the complete container lifecycle of its host system, from image transfer and storage to container execution and supervision to low-level storage to network attachments and beyond.再去看一下 containerd 的源码仓库 https://github.com/containerd/containerd从 Runtime Requirements 段落可以看到  Runtime requirements for containerd are very minimal. Most interactions with the Linux and Windows container feature sets are handled via runc and/or OS-specific libraries (e.g. hcsshim for Microsoft). The current required version of runc is described in RUNC.md.它是通过 runc 来完成交互的。我们再来查一下 runc, 它的仓库位于 https://github.com/opencontainers/runc runc 是一个用于生成和运行容易的 cli 工具我们知道 docker client 是通过 rest api 与 docker 的后台服务，即 dockerd 来交互的， dockerd 后面的 d 就是 daemon 守护进程的意思。 我们继续查看 docker 的文档 https://docs.docker.com/engine/reference/commandline/dockerd/#docker-runtime-execution-options  The Docker daemon relies on a OCI compliant runtime (invoked via the containerd daemon) as its interface to the Linux kernel namespaces, cgroups, and SELinux.By default, the Docker daemon automatically starts containerd. If you want to control containerd startup, manually start containerd and pass the path to the containerd socket using the –containerd flag.我们知道 docker client 调用了 dockerd,  dockerd 调用了 containerd, containerd 调用了 runc如何改变了Docker里的进程id这部分有点跳跃，直接说答案，是 unshare，文档链接：https://www.man7.org/linux/man-pages/man1/unshare.1.htmlunshare 命令创建了一个新的 namespaces ， 然后执行需要的程序，如果没有指定程序，则 执行 ${SHELL} 默认为 /bin/bash我们查看文档中的 CLONE_NEWPID 参数， 他的意思是取消共享进程ID的namespace，一边调用进程(calling process)有一个新的PID为子进程，其子进程的 namespace 不与任何先前存在的进程共享。 调用进程不会进入到新的 namespace ，调用进程创建的第一个子进程的ID为1，并将认为其在新的 namespace 中的身份为 init(1)namespace 里的进程再创建新的pid 为2 ，而且映射到最外成的id则是host里面的pid。我们再回到 watch 进程，在宿主机中查看他的 namespace，我们可以看到数字标识的不同的 namespace , 这个 namespace 和宿主机，比如 $$ shell进程的 namespace 有些是不一样的，有些则是一样的，比如 cgroup, user 等。 用户可以通过参数指定选择那些是共享的，哪些是不共享的，用此方式达到资源的隔离。calvin@yic:~/shared_data$ ps ax | grep watch   86 ?        S      0:00 [watchdogd] 3415 pts/0    S+     0:00 grep --color=auto watch26924 pts/0    S+     0:00 watch -d ps axcalvin@yic:~/shared_data$ sudo ls -lah /proc/26924/nstotal 0dr-x--x--x 2 root root 0 Apr 28 12:37 .dr-xr-xr-x 9 root root 0 Apr 28 12:20 ..lrwxrwxrwx 1 root root 0 Apr 28 12:37 cgroup -&gt; 'cgroup:[4026531835]'lrwxrwxrwx 1 root root 0 Apr 28 12:37 ipc -&gt; 'ipc:[4026532175]'lrwxrwxrwx 1 root root 0 Apr 28 12:37 mnt -&gt; 'mnt:[4026532173]'lrwxrwxrwx 1 root root 0 Apr 28 12:37 net -&gt; 'net:[4026532178]'lrwxrwxrwx 1 root root 0 Apr 28 12:37 pid -&gt; 'pid:[4026532176]'lrwxrwxrwx 1 root root 0 Apr 28 12:48 pid_for_children -&gt; 'pid:[4026532176]'lrwxrwxrwx 1 root root 0 Apr 28 12:37 user -&gt; 'user:[4026531837]'lrwxrwxrwx 1 root root 0 Apr 28 12:37 uts -&gt; 'uts:[4026532174]'calvin@yic:~/shared_data$ sudo ls -lah /proc/$$/nstotal 0dr-x--x--x 2 calvin calvin 0 Apr 28 12:19 .dr-xr-xr-x 9 calvin calvin 0 Apr 28 12:09 ..lrwxrwxrwx 1 calvin calvin 0 Apr 28 12:19 cgroup -&gt; 'cgroup:[4026531835]'lrwxrwxrwx 1 calvin calvin 0 Apr 28 12:19 ipc -&gt; 'ipc:[4026531839]'lrwxrwxrwx 1 calvin calvin 0 Apr 28 12:19 mnt -&gt; 'mnt:[4026531840]'lrwxrwxrwx 1 calvin calvin 0 Apr 28 12:19 net -&gt; 'net:[4026531992]'lrwxrwxrwx 1 calvin calvin 0 Apr 28 12:19 pid -&gt; 'pid:[4026531836]'lrwxrwxrwx 1 calvin calvin 0 Apr 28 12:53 pid_for_children -&gt; 'pid:[4026531836]'lrwxrwxrwx 1 calvin calvin 0 Apr 28 12:19 user -&gt; 'user:[4026531837]'lrwxrwxrwx 1 calvin calvin 0 Apr 28 12:19 uts -&gt; 'uts:[4026531838]'关于unshare的快速测试我们写一段c代码，用来获取当前的id，如下#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(void){    printf(\"pid:%d\\n\",getpid());    return 0;}编译一下输出可执行文件calvin@yic:~$ gcc -o getpid ./getpid.ccalvin@yic:~$ chmod u+x ./getpid使用 unshare 命令或 unshare()系统调用来创建一个新的 namespace，其中也包括 pid namespace（内核版本至少需要是3.8）需要注意的一个小点是，默认情况下，unshare 创建的 pid namespace 是作用在被调程序的子进程上，如下所示：calvin@yic:~$ sudo unshare -p ./getpidpid:11246使用 –fork 表示创建一个子进程，并在子进程中运行命令。从下面的示例可以看到，新的 pid namespace 在子进程上生效了，第一个子进程的 pid 为 1，即该 pid namespace 中的 init 进程。calvin@yic:~$ sudo unshare -p --fork ./getpidpid:1总结一下Docker Client –&gt; dockerd –&gt; containerd –&gt; runC –&gt; unshare syscall(namespace 隔离)参考文档  https://docs.docker.com/get-started/overview/#the-underlying-technology  https://containerd.io/  https://github.com/containerd/containerd  https://github.com/opencontainers/runc  https://www.man7.org/linux/man-pages/man1/unshare.1.html【全文完】"
  },
  
  {
    "title": "圣诞特辑-交换礼物",
    "url": "/2021/12/gift-exchange/",
    "categories": "技术",
    "tags": "javascript",
    "date": "2021-12-25 15:14:00 +0800",
    





    
    "snippet": "圣诞节到了，Team里面的小伙伴组织了一个交换礼物的活动，我也奉命接下了写个小工具的任务。需求需求很简单，就是将 人员名单 和 礼物清单 排成两列，然后随机摇出新的匹对，这样每个人就得到了新的礼物。算法核心算法其实很简单，就是将数组进行随机乱序排列，代码如下从后往前遍历，随机一个前面的数的坐标和当前数交换，所有位置的数字都交换完成function shuffle(arr) {    let ...",
    "content": "圣诞节到了，Team里面的小伙伴组织了一个交换礼物的活动，我也奉命接下了写个小工具的任务。需求需求很简单，就是将 人员名单 和 礼物清单 排成两列，然后随机摇出新的匹对，这样每个人就得到了新的礼物。算法核心算法其实很简单，就是将数组进行随机乱序排列，代码如下从后往前遍历，随机一个前面的数的坐标和当前数交换，所有位置的数字都交换完成function shuffle(arr) {    let i = arr.length;    while (i) {        let j = Math.floor(Math.random() * i--);        [arr[j], arr[i]] = [arr[i], arr[j]];    }}代码      采用 web 实现，这样表现力强一点，选择了 bootstrap 框架做为基础UI，使用 bootstrap 的 table 排列名单    考虑到只需要运行一次，所以维护人员名单，直接 Hard Code 到 html 页面里，临时增加人员，也只需要记事本打开修改一下即可  为了达到抽奖的效果，可以做一个 轮询 按下开始按钮后就不停的交换和刷新 人员名单 和 礼物名单，然后再按下按钮停止，即为最终结果最终实现效果如下：演示地址：https://www.caiyunlin.com/dev/gift-exchange/index.html可以直接另存为本地文件修改。【全文完】"
  },
  
  {
    "title": "C# Async Await 探究",
    "url": "/2021/08/csharp-async-await/",
    "categories": "技术",
    "tags": "csharp",
    "date": "2021-08-12 15:14:00 +0800",
    





    
    "snippet": "这篇文章源于同事问我的一个问题, async await 会不会创建新的线程?当时直观的感觉是会创建，觉得 async await 只是语法糖，当前线程没有被 block，而后台肯定需要做事，所以必然会创建新的线程去执行任务才对。然而查了文档，发现官方文档明确说明： async 和 await 关键字不会创建其他线程。 因为异步方法不会在其自身线程上运行，因此它不需要多线程。参考：https...",
    "content": "这篇文章源于同事问我的一个问题, async await 会不会创建新的线程?当时直观的感觉是会创建，觉得 async await 只是语法糖，当前线程没有被 block，而后台肯定需要做事，所以必然会创建新的线程去执行任务才对。然而查了文档，发现官方文档明确说明： async 和 await 关键字不会创建其他线程。 因为异步方法不会在其自身线程上运行，因此它不需要多线程。参考：https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/task-asynchronous-programming-model#threads如果没有创建线程，到底谁在后台执行任务呢？带着这个问题，好好捋一下 async await 这个新特性。子线程在没有 async 和 await 关键字的时候，如果我们需要在后台执行一些耗时任务时，就可以开启新的线程来完成。现在我们模拟一个耗时任务 doWord 函数，该函数完成一个加法并返回结果，为了模拟耗时，加入了 ms 参数用来 Sleep 模拟耗时。具体测试代码如下，我们在主线程中开启了两个子线程来执行两个耗时的任务，执行完成后输出得到的结果。    class Program    {        static void Print(string message)        {            string now = DateTime.Now.ToString(\"HH:mm:ss.fff\");            Console.WriteLine($\"{now} {message}\");        }        static int doWork(int a, int b, int ms = 1000)        {            int threadId = Thread.CurrentThread.ManagedThreadId;            Print($\"Current Thread ID is : {threadId} \");            Thread.Sleep(ms);            int result = a + b;            Print($\"Thread #{threadId} doWork:{a} + {b} = {result}\");            return result;        }        static void Main(string[] args)        {            Print(\"====Main Thread Start====\");            Print($\"Main Thread ID is : {Thread.CurrentThread.ManagedThreadId}\");            ThreadTest();            Print(\"====Main Thread End====\");            Console.ReadKey();        }        static void ThreadTest()        {            int result1 = 0;            int result2 = 0;            Thread thread1 = new Thread(() =&gt;            {                result1 = doWork(1, 1, 2000);                Print(\"Thread 1 Completed! \");            });            Thread thread2 = new Thread(() =&gt;            {                result2 = doWork(2, 2, 1000);                Print(\"Thread 2 Completed! \");            });            thread1.Start();            Print(\"Thread 1 Started! \");            thread2.Start();            Print(\"Thread 2 Started! \");            //wait thread to complete            thread1.Join();            thread2.Join();            Print($\"result1 = {result1}\");            Print($\"result2 = {result2}\");        }    }输出如下，为了方便表示执行的线程，我们 doWork 任务里面打印了”线程号”18:15:19.688 ====Main Thread Start====18:15:19.690 Main Thread ID is : 118:15:19.691 Thread 1 Started!18:15:19.692 Thread 2 Started!18:15:19.694 Current Thread ID is : 318:15:19.694 Current Thread ID is : 418:15:20.709 Thread #4 doWork:2 + 2 = 418:15:20.709 Thread 2 Completed!18:15:21.699 Thread #3 doWork:1 + 1 = 218:15:21.699 Thread 1 Completed!18:15:21.704 result1 = 218:15:21.704 result2 = 418:15:21.704 ====Main Thread End====我们可以看到主线程调用 ThreadTest 函数，创建了2个子线程，其中子线程1 耗时2秒，线程2耗时1秒，所以线程2先完成了。最后 thread1.Join() 和 thread2.Join() 用于阻塞等待两个线程，直到他们都执行完毕。这里需要注意，一定要 thread1.Join() 和 thread2.Join()，如果注释掉这两句，则返回结果如下18:15:39.162 ====Main Thread Start====18:15:39.164 Main Thread ID is : 118:15:39.165 Thread 1 Started!18:15:39.166 Thread 2 Started!18:15:39.167 result1 = 018:15:39.168 result2 = 018:15:39.168 ====Main Thread End====18:15:39.169 Current Thread ID is : 318:15:39.171 Current Thread ID is : 418:15:40.179 Thread #4 doWork:2 + 2 = 418:15:40.179 Thread 2 Completed!18:15:41.181 Thread #3 doWork:1 + 1 = 218:15:41.181 Thread 1 Completed!我们可以看到因为没有等待子线程的执行，Main Thread 提前结束了。 如果不是后面的 Console.ReadKey() 在等待，那么子线程可能没有执行完毕就被回收了。从上面可以看出，从子线程中取得执行结果的方式比较繁琐，而且必须控制好等待子线程执行完毕，否则可能不能得到正确的结果。异步编程 Async Await使用异步编程的方法，我们可以把耗时的函数封装成 async 的方法，然后在需要得到结果的地方使用 await。我们将上面的 doWork 包装到一个异步方法static async Task&lt;int&gt; doWorkAsync(int a, int b, int ms){    int result = await Task.Run(() =&gt;doWork(a, b, ms));    return result;}static async Task AsyncAwaitTest(){    int result1  = await doWorkAsync(1, 1, 2000);    int result2 = await doWorkAsync(2, 2, 1000);    Print($\"result1 = {result1}\");    Print($\"result2 = {result2}\");}将 Main 函数中的 ThreadTest() 换成 AsyncAwaitTest().Wait()，我们可以看到执行结果如下：18:16:03.864 ====Main Thread Start====18:16:03.866 Main Thread ID is : 118:16:03.893 Current Thread ID is : 318:16:05.899 Thread #3 doWork:1 + 1 = 218:16:05.901 Current Thread ID is : 418:16:06.914 Thread #4 doWork:2 + 2 = 418:16:06.915 result1 = 218:16:06.917 result2 = 418:16:06.917 ====Main Thread End====我们可以看到，异步方法执行的时候，实际上还是还有有其他线程来执行，其效果和线程的写法类似，但是写法上要简洁很多，也不需要定义全局变量来获取线程执行的结果。 大大减轻了编程的难度。 使用 await 关键字之后，一定会将正确的值复制到前面的变量，写法上与同步的方法类似，只是增加了 await 的关键字。注意，调用入口处，因为是同步函数，AsyncAwaitTest() 后面的 Wait() 方法是强制等待异步方法执行完毕，这个和前面 thread.Join 类似，但是不用单独管理线程。总结所以异步方法执行是会产生线程的，我们再回头看文档https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/task-asynchronous-programming-model#threads原来其强调的是 async 和 await 关键字不会创建其他线程，但是在真正执行到任务是，比如 调用 Task.Run 方法时，才会占用子线程，该子线程由 Task 来管理，而不需要我们手动去 new Thread，也不需要用 ThreadPool 来管理。有关于 async 方法的调用机制，可以参考下面官方截图和解释关系图中的数字对应于以下步骤，在调用方法调用异步方法时启动。      调用方法调用并等待 GetUrlContentLengthAsync 异步方法。        GetUrlContentLengthAsync 可创建 HttpClient 实例并调用 GetStringAsync 异步方法以下载网站内容作为字符串。        GetStringAsync 中发生了某种情况，该情况挂起了它的进程。 可能必须等待网站下载或一些其他阻止活动。 为避免阻止资源，GetStringAsync 会将控制权出让给其调用方 GetUrlContentLengthAsync。    GetStringAsync 返回 Task，其中 TResult 为字符串，并且 GetUrlContentLengthAsync 将任务分配给 getStringTask 变量。 该任务表示调用 GetStringAsync 的正在进行的进程，其中承诺当工作完成时产生实际字符串值。        由于尚未等待 getStringTask，因此，GetUrlContentLengthAsync 可以继续执行不依赖于 GetStringAsync 得出的最终结果的其他工作。 该任务由对同步方法 DoIndependentWork 的调用表示。        DoIndependentWork 是完成其工作并返回其调用方的同步方法。        GetUrlContentLengthAsync 已运行完毕，可以不受 getStringTask 的结果影响。 接下来，GetUrlContentLengthAsync 需要计算并返回已下载的字符串的长度，但该方法只有在获得字符串的情况下才能计算该值。    因此，GetUrlContentLengthAsync 使用一个 await 运算符来挂起其进度，并把控制权交给调用 GetUrlContentLengthAsync 的方法。 GetUrlContentLengthAsync 将 Task&lt;int&gt; 返回给调用方。 该任务表示对产生下载字符串长度的整数结果的一个承诺。    备注    如果 GetStringAsync（因此 getStringTask）在 GetUrlContentLengthAsync 等待前完成，则控制会保留在 GetUrlContentLengthAsync 中。 如果异步调用过程 getStringTask 已完成，并且 GetUrlContentLengthAsync 不必等待最终结果，则挂起然后返回到 GetUrlContentLengthAsync 将造成成本浪费。    在调用方法中，处理模式会继续。 在等待结果前，调用方可以开展不依赖于 GetUrlContentLengthAsync 结果的其他工作，否则就需等待片刻。 调用方法等待 GetUrlContentLengthAsync，而 GetUrlContentLengthAsync 等待 GetStringAsync。        GetStringAsync 完成并生成一个字符串结果。 字符串结果不是通过按你预期的方式调用 GetStringAsync 所返回的。 （记住，该方法已返回步骤 3 中的一个任务）。相反，字符串结果存储在表示 getStringTask 方法完成的任务中。 await 运算符从 getStringTask 中检索结果。 赋值语句将检索到的结果赋给 contents。        当 GetUrlContentLengthAsync 具有字符串结果时，该方法可以计算字符串长度。 然后，GetUrlContentLengthAsync 工作也将完成，并且等待事件处理程序可继续使用。 在此主题结尾处的完整示例中，可确认事件处理程序检索并打印长度结果的值。 如果你不熟悉异步编程，请花 1 分钟时间考虑同步行为和异步行为之间的差异。 当其工作完成时（第 5 步）会返回一个同步方法，但当其工作挂起时（第 3 步和第 6 步），异步方法会返回一个任务值。 在异步方法最终完成其工作时，任务会标记为已完成，而结果（如果有）将存储在任务中。  【全文完】"
  },
  
  {
    "title": "解决端口占用问题",
    "url": "/2021/08/fix-port-in-use-issue/",
    "categories": "技术",
    "tags": "windows, linux",
    "date": "2021-08-01 17:15:00 +0800",
    





    
    "snippet": "端口被占用是指当你的可执行程序运行时需要在某个端口侦听时，发现该端口被其他程序给占用了，导致该应用程序无法执行。如: jekyll 默认需要在端口 4000 侦听，当被占用的时候，会显示错误 Permission denied - bind for 127.0.0.1:4000本地的 4000 端口被占用。解决方法      查看端口的占用情况    # 查看端口占用情况netstat -a...",
    "content": "端口被占用是指当你的可执行程序运行时需要在某个端口侦听时，发现该端口被其他程序给占用了，导致该应用程序无法执行。如: jekyll 默认需要在端口 4000 侦听，当被占用的时候，会显示错误 Permission denied - bind for 127.0.0.1:4000本地的 4000 端口被占用。解决方法      查看端口的占用情况    # 查看端口占用情况netstat -ano# 也可以使用 find 过滤netstat -ano | find \"4000\"        参数：          -a：显示所有链接和侦听端口      -n：以数字形式显示地址和端口号      -o：显示拥有的与每个连接关联的进程 ID 即 PID            查看当前占用端口服务    tasklist /svc /FI \"PID eq 1172\"    显示如下，我们知道 端口被 FoxitProtect.exe 福昕阅读器占用了    映像名称                       PID 服务========================= ======== ============================================FoxitProtect.exe              1172 FxService        参数：          /svc：如果这个进程是一个 Windows 服务的话同时显示这个服务的名称      /FI：使用筛选器对结果进行筛选            对目标服务进行关闭    # 停止 FxService 服务程序， 或者使用 services.msc 打开服务管理器,停止或禁用该服务net stop FxService  Linux 下的解决办法在 Linux 下也可以使用同样方式查询和关闭服务，命令参数有少许区别  根据端口号，查询进程名称和进程IDnetstat -tunlp | grep 8080输出如下：如果最后一个 PID/Program name 只显示了 - ，没有显示具体的进程，则在 netstat 前面加上 sudocalvin@yic:~$ sudo netstat -tunlp | grep 8080tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      9299/nginx: mastertcp6       0      0 :::8080                 :::*                    LISTEN      9299/nginx: master参数说明：      -t: 显示 TCP 连接        -u: 显示 UDP 连接        -n: 显示数字地址        -l: 列出状态是 LISTEN 的统计信息        -p: 显示程序的PID和名称        停止相关服务    sudo systemctl stop nginx      【全文完】"
  },
  
  {
    "title": "汇编语言基础",
    "url": "/2021/07/assembly-primer/",
    "categories": "技术",
    "tags": "bash, ubuntu, assembly",
    "date": "2021-07-17 09:41:00 +0800",
    





    
    "snippet": "最近查一些文章，涉及到了汇编语言，所以翻出一些资料复习一下。我们平常学习的编程语言，如 C, C++, Java, C#,Python等等都是高级语言。我们也都知道，机器只能理解执行0101的代码，那高级语言如何转换为机器语言的？其实高级语言是通过编译器转换为机器语言的，在编译过程中间会生成一个过渡性的语言，叫汇编语言，高级语言屏蔽了实现的细节，如对内存的操作，而汇编语言是低级语言，是通过指...",
    "content": "最近查一些文章，涉及到了汇编语言，所以翻出一些资料复习一下。我们平常学习的编程语言，如 C, C++, Java, C#,Python等等都是高级语言。我们也都知道，机器只能理解执行0101的代码，那高级语言如何转换为机器语言的？其实高级语言是通过编译器转换为机器语言的，在编译过程中间会生成一个过渡性的语言，叫汇编语言，高级语言屏蔽了实现的细节，如对内存的操作，而汇编语言是低级语言，是通过指令直接对硬件，如CPU的寄存器和内存进行操作的语言，早期的程序员也是直接写汇编语言来控制程序运行，了解汇编语言有助于明白底层的实现，进而可以增加排错能力，以及优化代码。一点背景汇编语言是针对CPU设计的，每一种CPU都有自己的汇编指令集，所以针对不同的CPU的汇编语言写法是不一样的，比如 ARM(安卓手机CPU) 和 Intel(常用PC CPU) 他们的指令格式是不一样的。 即便是同一款CPU，指令格式上也可以不一样，常用的有 ATT 汇编格式和 Intel汇编格式。通常一条汇编指令包含操作码和操作数两部分内容，格式为 操作码(OP) 操作数如 mov $20 %al 表示将立即数20保存到寄存器 al中去，这个写法是 ATT格式，如果用 Intel汇编代码格式写，那对应的代码就是 MOV AL, 20H  ATT 与 Intel 汇编代码格式：  Intel 汇编格式比较好理解，因为芯片是Intel生产的，他们自然设置了对应的汇编代码格式。  ATT（根据 “AT&amp;T”命名的，AT&amp;T是运营贝尔实验室多年的公司）格式的汇编代码，这是GCC,OBJDUMP等工具的默认格式，贝尔实验室是Unix系统的创建者，Linux 是 Unix 家族的一员，早期Linux所使用的的386汇编语言也是起源于Unix，Unix最初是为PDP－11开发的，曾先后被移植到VAX及68000系列的处理器上，这些处理器上的汇编语言都采用的是AT&amp;T的指令格式。当Unix被移植到i386时，自然也就采用了AT&amp;T的汇编语言格式，而不是Intel的格式。ATT语法和Intel语法的一些区别在ATT语法中，寄存器前冠以％，而立即数前冠以$，在Intel的语法中，寄存器和和立即数都没有前缀。在ATT语法中，十六进制立即数前冠以“0x”，而在Intel的语法中，十六进制和二进制立即数后缀分别冠以h和b在 Ubuntu GCC 编译器中默认是 ATT 语法，本文也主要以ATT语法来示例。寄存器上面的示例代码中，命令 mov $10 %al是将数字 10 放到寄存器 al 中，那al是指哪个寄存器呢，可以参考下面的图表下图是 8086 16位寄存器的简要介绍， AX 是累加寄存器，包含高位 AH 和 低位 AL，所以上述命令就是将数字 10 放到 累加寄存器的低位中。上图是 16 位CPU的架构图，目前大部分的系统都是 64 位的CPU，可以参考下面的表格，第一行表示位数，高位的包含低位            63~32      31~16      15~8      7~0      说明                  %rax      %eax      %ax      %al      ==返回值==              %rbx      %ebx      %bx      %bl      Callee Saved              %rcx      %ecx      %cx      %cl      第4个参数              %rdx      %edx      %dx      %dl      第3个参数              %rsi      %esi      %si      %si      第2个参数              %rdi      %edi      %di      %di      第1个参数              %rbp      %ebp      %bp      %bp      Callee Saved              %rsp      %esp      %sp      %sp      ==栈指针==              %r8      %r8d      %r8w      %r8b      第5个参数              %r9      %r9d      %r9w      %r9b      第6个参数              %r10      %r10d      %r10w      %r10b      Caller Saved              %r11      %r11d      %r11w      %r11b      Caller Saved              %r12      %r12d      %r12w      %r12b      Callee Saved              %r13      %r13d      %r13w      %r13b      Callee Saved              %r14      %r14d      %r14w      %r14b      Callee Saved              %r15      %r15d      %r15w      %r15b      Callee Saved      如 movl $10, %eax 和 mov $10 %ax 是类似的效果，注意 ATT 的 mov 命令后面可以跟字长表示长度 ，字长定义如下 ：            C声明      Intel数据类型      汇编代码后缀      大小（字节）                  char      字节(byte)      b      1              short      字(word)      w      2              int      双字(double word)      l      4              long      四字(quad word)      q      8              char*      四字      q      8              float      单精度      s      4              double      双精度      l      8      一个简单的例子将下面文件保存为 main.cint main(){    return 0;}使用尝试使用gcc编译生成汇编, gcc -O 的参数是生成原始的汇编的命令，没有这个参数会生成经过优化的汇编命令$ gcc -Og -S -o main.s main.c$ cat main.s        .file   \"main.c\"        .text        .globl  main        .type   main, @functionmain:.LFB0:        .cfi_startproc        movl    $0, %eax        ret        .cfi_endproc.LFE0:        .size   main, .-main        .ident  \"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0\"        .section        .note.GNU-stack,\"\",@progbits上述代码中 .file 大部分为汇编的描述代码，不会生成具体机器指令，我们可以忽略， 简化上面的汇编代码如下.global mainmain:    movq $0, %rax    ret稍微解释下这段代码， .global main 是告诉汇编器， main 为主要入口， movq $0, %rax 是指将立即数 0 移到累加寄存器 rax，rax也是返回数寄存器，程序最后的运行结果就放在这个寄存器中。 ret 就是 return 的缩写，是退出程序。这段代码主要功能就是返回一个运行结果 0 ，然后退出。我们将上述汇编代码保存为 testmain.s ，然后使用 gcc 来编译输出可执行文件$ gcc -o testmain testmain.s./testmain$ echo $? # 查询运行结果0我们可以将上述 movq $0 改成其他数字如 movq $10 ，重新编译测试结果，会发现最终结果也会改变。简单的加法上面的代码，我们直接操作了累加寄存器设置了返回值，这一节我们仍然使用 c 反汇编来看一下加法的实现。将下面文件保存为 testaddab.cint addab(int a, int b){    return a+b;}int main(){    return addab(2,3);}使用gcc编译$ gcc -Og -S -o testaddab.s testaddab.c$ cat testaddab.s        .file   \"testaddab.c\"        .text        .globl  addab        .type   addab, @functionaddab:.LFB0:        .cfi_startproc        leal    (%rdi,%rsi), %eax        ret        .cfi_endproc.LFE0:        .size   addab, .-addab        .globl  main        .type   main, @functionmain:.LFB1:        .cfi_startproc        movl    $3, %esi        movl    $2, %edi        call    addab        rep ret        .cfi_endproc.LFE1:        .size   main, .-main        .ident  \"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0\"        .section        .note.GNU-stack,\"\",@progbits# 输出可执行文件$ gcc -o testaddab testaddab.s$ ./testaddab # 执行程序$ echo $?     # 查看执行结果简化上面的编码如下，保存为 testadd.s：.global addabaddab:    leal (%rdi,%rsi), %eax    ret.global mainmain:    movl $3, %esi    movl $2, %edi    call addab    rep ret重复上面的编译步骤，我们会得到如下结果$ gcc -o testadd testadd.s$ ./testadd$ echo $?5我们可以看到 movl 将 3，和 2 分别放到寄存器 esi 和 edi， 然后调用函数 leal ，注意 lea 是 intel 的指令 (Load effect address ) 也就是取有效地址的意思，可以用它在实现快速的加法以及简单的乘法。Hello World!下面我们写一段 hello world，和其他高级语言不一样，因为CPU只能做数值运算，而 hello world 涉及到显示，也就是IO，所以我们必须调用操作系统的函数来完成文本的输出， 将下面文件保存到 helloworld.s    .section .datamessage:    .ascii \"hello world!\\n\"    length = . - message    .section .text    .global mainmain:    movq $1, %rax    movq $1, %rdi    lea message(%rip), %rsi    movq $length, %rdx    syscall    movq $60, %rax    xor %rdi, %rdi    syscall编译执行$ gcc -o helloworld helloworld.s$ ./helloworldHello World!总结汇编语言是针对硬件直接编程的语言，命令的格式为 操作码 操作数汇编语法有 ATT 和 Intel 之分可以通过操作寄存器设置程序的返回值需要显示字符，需要调用系统函数 syscall参考https://www.cs.virginia.edu/~evans/cs216/guides/x86.html【全文完】"
  },
  
  {
    "title": "在 Ubuntu 上安装 Nginx 并支持 PHP",
    "url": "/2021/05/install-php-for-nginx-on-ubuntu/",
    "categories": "技术",
    "tags": "bash, ubuntu, nginx",
    "date": "2021-05-05 13:45:00 +0800",
    





    
    "snippet": "  最近整理了一下博客系统，迁移到了Jekyll模板，发现Apache2服务器不支持中文路径，研究了一番没有找到解决方法，测试了nginx可以默认支持中文路径，遂整理一下，把 Apache2 换成了 Nginx本文所述的步骤在 Ubuntu 18.04 上测试通过。安装 Nginx使用 apt-get 安装 nginx# 更新 APT 源sudo apt-get update# 安装 ngi...",
    "content": "  最近整理了一下博客系统，迁移到了Jekyll模板，发现Apache2服务器不支持中文路径，研究了一番没有找到解决方法，测试了nginx可以默认支持中文路径，遂整理一下，把 Apache2 换成了 Nginx本文所述的步骤在 Ubuntu 18.04 上测试通过。安装 Nginx使用 apt-get 安装 nginx# 更新 APT 源sudo apt-get update# 安装 nginxsudo apt-get install nginx安装完成后测试一下 nginx 的版本，查看是否安装成功nginx -v启动 nginxservice nginx start服务自动后，输入服务器所在的IP地址，应该可以看到nginx的欢迎界面 “Welcome to nginx!”安装 PHP不像 Apache2, Nginx 没有包含自带的PHP处理引擎。 所以需要安装一个 PHP-FPM (FastCGI Porcess Manager) 来支持 PHP 的执行。 FPM 是一个 PHP FastCGI 的实现，可以非常好的支持大并发的php站点。第一步你需要添加 Ubuntu 的 universe repository ，这样保证可以获取到最新的 php-fpm 包sudo add-apt-repository universe接下来更新软件包，然后安装 php-fpm, 后续还会安装 php-mysql ， 这样 php 可以访问 MySQL 数据库，输入命令后按 Y 和回车继续。sudo apt update &amp;&amp; sudo apt install php-fpm# 如果需要使用 MYSQL，执行下面脚本安装 php-mysqlsudo apt install php-mysql安装完成之后，检查 php 的版本php --version# 如果安装成功，应该可以看到下面类似的消息PHP 7.2.24-0ubuntu0.18.04.7 (cli) (built: Oct  7 2020 15:24:25) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies    with Zend OPcache v7.2.24-0ubuntu0.18.04.7, Copyright (c) 1999-2018, by Zend Technologies上面列出的 PHP 版本是 7.2, 这个版本可以根据你的 repository 的包有略微不同。 根据你安装的 Nginx 和 PHP 版本，你需要手动配置一下 PHP Socket 的路径，这样 Nginx 可以连接上它。下面列出 /var/run/php 的内容ls /var/run/php php7.2-fpm.pid  php7.2-fpm.sock这里我们可以看到 php7.2-fpm.sock 接下来会用到它。配置 Nginx 的多站点如果你希望 Nginx 支持多个站点，可以 复制 /etc/nginx/sites-available/default ，如 example.comcd /etc/nginx/sites-availablecp default example.com.confcp default example2.com.conf打开对应的 example.com.conf 文件，修改其中的 server_name 和 root 指定到对应的目录，如下注意删掉 listen 后面的 default_server 因为默认只能有一个 default_server, 在 default 文件中已经定义了  listen 80;  listen [::]:80 ;  # .....  root /var/www/example.com;  # Add index.php to the list if you are using PHP  index index.html index.htm index.nginx-debian.html;  server_name example.com;  location / {          # First attempt to serve request as file, then          # as directory, then fall back to displaying a 404.          try_files $uri $uri/ =404;  }修改完成后，激活该站点cd /etc/nginx/sites-enabledsudo ln -s /etc/nginx/sites-available/example.com.conf example.com.confsudo ln -s /etc/nginx/sites-available/example2.com.conf example2.com.conf配置 Nginx 的 PHP 扩展我们现在配置一下 Nginx 的 server 定义，默认 server 定义的路径在 /etc/nginx/sites-available/default 当然根据的你安装定义，路径可能在其他自定义的地方。如果你的 Nginx 是支持多个域名的，你的配置文件可能是 /etc/nginx/sites-available/example.com使用 nano 工具，编辑文件sudo nano /etc/nginx/sites-available/default添加默认文件，支持 index.php在 nano 里面，按下 ctrl+w 搜索 index.html，如下所示，在 index.html 前面或者后面，添加 index.phpindex index.php index.html index.htm index.nginx-debian.html;配置 Server Name，如果需要，将你的自定义域名写到 server_name 后面server_name YOUR_DOMAIN_OR_IP_HERE;配置 PHP Socket按下 CTRL + W 搜索 location ~ .php 那一行你可以去掉注释符号 #, 注意 fastcgi_pass 指向到我们上一步查到 php7.2-fpm.sock 的路径location ~ \\.php$ {                include snippets/fastcgi-php.conf;        #        #       # With php-fpm (or other unix sockets):                fastcgi_pass unix:/var/run/php/php7.2-fpm.sock;        #       # With php-cgi (or other tcp sockets):        #       fastcgi_pass 127.0.0.1:9000;        }这里注意，如果是php需要支持pathinfo的，则去掉后面的 $ ，如 location ~ .php，在 snippets/fastcgi-php.conf 中，对 PATH_INFO 做了处理，不需要再引入其他代码。注意不要忘掉删掉花括号 } 前面的 # 注释符保存和测试 Nginx 配置所有修改完毕之后，按下 Ctrl + X ，然后输入 y 和 回车保存内容。执行下面的语句，保证配置修改正确了sudo nginx -t输入应该如下：nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful如果没有问题，执行下面语句重启 nginxsudo service nginx reload测试 PHP要想知道 PHP 是否正常工作，在 nginx web 根目录创建一个 PHP 文件，如 info.php, 默认的web目录应该是 /var/www/html, 如果你的服务器配置了多站点，路径可能是 /var/www/example.com/html ， 知道的 web 根目录，后使用 nano 创建 info.php 文件sudo nano /var/www/html/info.php输入以下内容&lt;?phpphpinfo();按下 Ctrl + X ，然后输入 y 和 回车保存内容。访问你的服务器地址或者域名，如 https://example.com/info.php 如果看到正常的 php 输出，则表示PHP配置安装成功了。安装 phpmyadminsudo apt install phpmyadmin# 链接本地 phpmyadmin 到 phpmyadmin 的 安装目录sudo ln -s phpmyadmin /usr/share/phpmyadmin# 如果 nginx 访问 phpmyadmin 的图片等静态资源有 Access Denied 的问题，也可以直接拷贝文件夹到 web 当前目录下cp /usr/share/phpmyadmin phpmyadmin -r【全文完】"
  },
  
  {
    "title": "基于 PowerShell 的 Web Server 简单实现",
    "url": "/2020/11/powershell-webserver/",
    "categories": "技术",
    "tags": "sublime, markdeep",
    "date": "2020-11-05 17:00:00 +0800",
    





    
    "snippet": "最近项目中有个需求，就是现有很多已经存在的PowerShell脚本，但是命令行的方式不是很方便使用，希望能集成到一个Web界面，简化用户操作难度。经过简单调研，发现可以使用 HttpListener 创建一个对象在本地侦听在自对应端口，就可以实现一个简单的Web服务器，具体实现如下。简单实现先创建一个POC，代码如下，保存到 webserver.ps1$http = [System.Net....",
    "content": "最近项目中有个需求，就是现有很多已经存在的PowerShell脚本，但是命令行的方式不是很方便使用，希望能集成到一个Web界面，简化用户操作难度。经过简单调研，发现可以使用 HttpListener 创建一个对象在本地侦听在自对应端口，就可以实现一个简单的Web服务器，具体实现如下。简单实现先创建一个POC，代码如下，保存到 webserver.ps1$http = [System.Net.HttpListener]::new()$http.Prefixes.Add(\"https://localhost:8080/\")$http.Start()if ($http.IsListening) {    write-host \"HTTP Server Ready!  \" -f 'black' -b 'gre'    write-host \"$($http.Prefixes)\" -f 'y'}# INFINTE LOOP, Used to listen for requestswhile ($http.IsListening) {    $context = $http.GetContext()    $body = \"Hello World!\"    $buffer = [System.Text.Encoding]::UTF8.GetBytes($body)    $context.Response.ContentLength64 = $buffer.Length    $context.Response.OutputStream.Write($buffer, 0, $buffer.Length)    $context.Response.Close()}打开管理员模式运行 PowerShell 窗口，执行 .\\webserver.ps1 , 注意如果遇到执行权限的问题，则先执行 Set-ExecutionPolicy ByPass执行后，输入 https://localhost:8080，应该可以看到 Hello World! 页面前端页面上一步，我们实现了一个简单的POC，输入 https://localhost:8080 之后，就能看到 Hello World!。 此时无论输入任何的路径，都是只能返回同样的内容。所以这一步我们需要做一个实现，即，用户输入 html 文件的 url 时候，读取 wwwroot 目录下该文件的内容，显示到浏览器。我们先要获取到用户请求的URL,然后匹配到本地的文件路径，如果存在读取文件，不存在，则返回404# 在while循环里面 增加如下代码$RequestUrl = $context.Request.Url.LocalPathWrite-Host \"$((Get-Date).ToString('yyyy-MM-dd HH:mm:ss')) : $($context.Request.Url)\" -f 'mag'# Get Request Urlif ($context.Request.HttpMethod -eq 'GET') {           # Redirect root to index.html    if($RequestUrl -eq \"/\") {      $RequestUrl = \"/index.html\"    }    if(Test-Path \"$scriptPath\\$webPath\\$RequestUrl\"){        $ContentStream = [System.IO.File]::OpenRead( \"$scriptPath\\$webPath\\$RequestUrl\" );        $ContentStream.CopyTo( $Context.Response.OutputStream );    }    else{        Send-WebResponse $context \"404 : Not found $RequestUrl\"                }    $context.Response.Close()}# 注意这里为404封装了一个函数 Send-WebResponse，这样可以统一返回文本消息function Send-WebResponse($context, $content) {    $buffer = [System.Text.Encoding]::UTF8.GetBytes($content)    $context.Response.ContentLength64 = $buffer.Length    $context.Response.OutputStream.Write($buffer, 0, $buffer.Length)}后端控制器在上面一步，我们用 Get 可以获取到文件的内容，那么涉及到后台交互时，如何处理呢。我们可以假定，所有的 POST 请求，都是作为调用后端逻辑来处理的。 当前台 html 页面使用 ajax 提交 POST 请求时， 如 /dosomething， 则调用到 controller/dosomething.ps1。然后 controller/dosomething.ps1 处理具体的逻辑，在返回最终 json 到前台，完成一次前后台的交互。 简单实现如下if($context.Request.HttpMethod -eq \"POST\"){    $controllerFile = \"$scriptPath/$controllerPath/$RequestUrl.ps1\"    if(Test-Path $controllerFile){        try{            $postData = Get-PostData $context                       . $controllerFile        }        catch{            $jsonObj = @{                'status' = 'error'                'message' = $_.ToString()            }            $json =  ConvertTo-JSON $jsonObj            Send-WebResponse $context $json        }    }    else{        Send-WebResponse $context \"{`\"status`\":`\"error`\",`\"message`\":`\"Unsupported API $RequestUrl`\"}\";    }    $context.Response.Close()}参数传递前台直接提交数据到后台是，有时PowerShell不能处理特殊的控制字符，所以前台会将数据进行 URL ENCODE 和 BASE64 ENCODE，后台则统一拦截反向解码，再传入 controller 中，controller 中的代码直接使用 $postData.property 即可访问前台传递过来的数据，这样一个简单的MVC框架就搭建好了。// 前端//get encoded data and post to powershell backendfunction get_encoded_data(data){    var jsonString = JSON.stringify(data);    var urlEncodedData = encodeURIComponent(jsonString);    // use base64 so powershell could parse    var base64Data = btoa(urlEncodedData);    // '=' has special meaning in querystring, like a=b, need replace them    var resultData = base64Data.replace(/=/g,\"%3D\");    return resultData}# 后端function Get-PostData{    $reader = new-object System.IO.StreamReader($context.Request.InputStream)    $text = $reader.ReadToEnd()    $text = $text.Replace(\"%3D\",\"=\")    $text = ConvertFrom-Base64 $text    $text = [System.Web.HttpUtility]::UrlDecode($text)    Write-Host \"$text\"    return ConvertFrom-Json $text}中文编码为了兼容中文处理，前端返回到后台的数据统一用UTF8格式，文件编码也统一为UTF8，html头部也需加上 &lt;meta charset=”utf-8” /&gt; 否则会出现乱码使用场景除了文章最开始的提到的整合本地 PowerShell 脚本到web界面外，这个方案还适合发布最简单的 web 原型应用到用户本地，因为默认Windows机器都自带了 PowerShell，所以不需要安装任何其他东西，比较方便。详细代码本文的详细代码发布在 https://github.com/cylin2000/powershell-webserver缺点  目前此方案只支持单线程，即在Web端如果开启多个页面，当第一个页面请求没有完成的时候，第二个页面会是一直处于等待状态，直到第一个页面的代码处理结束。 如果只是本地个人小规模应用，应该问题不大。  $httpListener 对象因为一直处于无限循环的侦听中，所以当启动起来后，普通的Ctrl+C不能终止程序的运行，必须关掉整个powershell的进程才行。【全文完】"
  },
  
  {
    "title": "Bash 踩坑指南",
    "url": "/2020/04/bash-experience/",
    "categories": "技术",
    "tags": "bash, shell",
    "date": "2020-04-07 17:44:00 +0800",
    





    
    "snippet": "  最近项目逐步迁移到AWS平台上，相关的代码管理和自动化部署也由TFS迁移到GitHub+Jenkins方案上，为此写了不少的bash脚本用来自动化部署和测试，也踩了相当多的坑，在此总结一下。Shell的种类和Windows平台不一样，在Linux系统下，有多种Shell，所以同样的脚本，不同的解释器执行结果可能是不一样的，下面列举了常见的Shell种类。  sh : sh 的全称是 Bo...",
    "content": "  最近项目逐步迁移到AWS平台上，相关的代码管理和自动化部署也由TFS迁移到GitHub+Jenkins方案上，为此写了不少的bash脚本用来自动化部署和测试，也踩了相当多的坑，在此总结一下。Shell的种类和Windows平台不一样，在Linux系统下，有多种Shell，所以同样的脚本，不同的解释器执行结果可能是不一样的，下面列举了常见的Shell种类。  sh : sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了，是第一个流行的shell  bash : Bourne-Again SHell  dash ： theDebian Almquist Shell， Ubuntu的/bin/sh默认链接到dash  csh, tcsh, zsh, oh-my-zsh  busybox : 小巧的工具套件，1M大小，集成了上百个内置命令其中Bash是使用比较广泛的一种，大部分Linux系统的默认登陆Shell就是Bash，市面上大部分脚本也是Bash脚本。如何查看当前系统支持的shell呢，执行cat /etc/shells$ cat /etc/shells# /etc/shells: valid login shells/bin/sh/bin/bash/bin/rbash/bin/dash下面几种方法可以查询当前使用的Shell相关信息  ps -p $$ – 查询你当前正在使用的Shell  echo \"$SHELL\" – 查询当前用户的默认Shell，但是不一定是你正在使用的Shell，比如你默认的shell是/bin/bash，但是你切换到了dash模式下，用这个命令查看，他的返回还是 /bin/bash  echo $0 – 另一个比较可靠的方法查询当前的Shell，你现在使用的是什么Shell就返回什么  ls -al /bin/sh - 检查默认 sh 的解释器是哪个。 比如 sh 指向的是 dash, 那使用 sh xxx.sh 就相当于 dash xxx.sh在Jenkins里面，常常使用Docker构建一个Shell执行环境，所以根据你使用的Docker镜像不同，默认使用的Shell也不同，你可以使用上面的命令去测试当前的SHELL种类。Shell不同，对命令的支持力度也不同，这里列举几个简单的Bash和Dash区别。  Bash 支持 function 关键字 , Dash 不支持  Bash 支持快速大小写转换, Dash 不支持    str=\"hello\"str2=\"WORLD\"echo ${str^^}echo ${str2,,}        Bash 支持 &lt;&lt;&lt; 重定向, Dash 不支持Shell的交互方式      login shell login shell 是你登陆到系统里是的默认shell，不管是通过终端或者通过SSH来连接，login shell会默认加载下面的文件，如果文件存在的话 .profile,.bash_profile,.bash_login    interactive shell interactive shell 是当你在shell里面了，你输入了另外一个shell的名字，比如 bash 或者 dash, 你就进入了交互式shell环境，此时也会加载默认配置，比如 bash shell 会自动 .bashrc 所以，你可以把相关预定义配置放到这个文件里面，下面的命令可以测试已经开启的shell,使用exit可以退出交互式Shell    bashpsdashps        non-interactive shell non-interactive shell 是一个用户无法交互的Shell，一般都是用来执行自动化脚本. Jeknins 就是在使用 non-interactive shell.比如Ubuntu系统，当你登录了系统是，默认的登陆Shell是bash, 但是当你在Jenkins使用Ubuntu作为Docker镜像时，默认的Shell是 non-interactive shell, 他指向的是 dash, 如果我们使用的是基于 alpine 的linux，那么默认的 non-interactive shell 可能是 busyboxShell的执行类型  forkfork 模式会复制当前进程信息并且创建一个副本进程，把副本进程作为当前进程的Child.用下面的内容创建文件 fork-test.sh 来测试一下forkecho \"fork-test.sh start\"psecho \"fork-test.sh end\"用下面文件调用 fork-test.sh, 执行之前可以先调用 ps 查看当前进程，然后执行后再观察当前进程，你会发现 fork-test会创建新的bash进程，然后执行完毕之后，又自动销毁掉。 进程中产生的环境变量等信息会一起销毁掉。pschmod 777 ./fork-test.sh./fork-test.sh &amp;&amp; ps# or bash fork-test.sh &amp;&amp; ps  sourcesource 会在当前进程中直接执行脚本，不会创建新的子进程。使用下面的脚本测试，然后观察进程，你会发现没有新的进程产生，然后注意使用source不需要为脚本文件指定执行权限。source fork-test.sh &amp;&amp; ps# or. fork-test.sh &amp;&amp; ps  execexec 和 source是一样的，不会产生新的子进程，但是它有个不一样的是，他执行被调用的脚本之后，会退出之前的脚本环境，所以当被调用脚本执行完毕退出之后，你会发现当前的shell也退出了。这个使用场景比较少，一半不经常使用。psexec ./fork-test.sh 环境变量加入我们在Jenkins里面定义了一个环境变量, 比如 DEPLOY_ENV=SB, 在Bash中如何使用呢？  不管是 fork 还是 source 来调用脚本，都可以直接使用上层定义的环境变量, 但是使用 fork的话，你没有办法修改变量并且将它返回到调用的地方。 用下面的脚本可以测试export DEPLOY_ENV=\"SB\"# create env-test-sb.sh with following linesecho \"DEPLOY_ENV is $DEPLOY_ENV\"# create env-test-dev.sh with following linesecho \"UPDATE DEPLOY_ENV to DEV\"export DEPLOY_ENV=\"DEV\"echo \"DEPLOY_ENV is $DEPLOY_ENV\"bash env-test-sb.shbash env-test-dev.shecho \"DEPLOY_ENV is $DEPLOY_ENV\"  如果我们期望能改变环境变量，那必须要使用 source. env-test-dev.shecho \"DEPLOY_ENV is $DEPLOY_ENV\"在Jenkins中如何用好Bash  在每一个sh脚本上面写上 #!/bin/bash， 这样脚本默认使用bash来解释执行  在Jenkins的sh代码块中，显示的使用bash命令来调用脚本，比如    sh '''        echo 'Executing Deploy in SandBox'        bash ./deploy.sh        rc=$?; if [[ $rc != 0 ]]; then exit 1; else echo \"deploy completed\"; fi    '''\t因为bash会自动fork一个新的进程去执行实际脚本，所以最后必须拦截处理脚本的返回信息，这样有错误可以再提交到Jenkins中显示出来。  在 deploy.sh 脚本中，再次调用其他脚本时，可以使用 source 方式，这样可以共享处理环境变量。注意空格写法# 赋值正确写法a=1# 错误写法a = 1 # if 和条件语句块之间必须要有空格,[] 里面两端也必须要有空格a=10b=20if [ ${a} -eq ${b} ]then  echo \"相等\"else  echo \"不等\"fi快速检查变量[ -n \"${AWS_ACCESS_KEY_ID}\" ] || { echo \"AWS_ACCESS_KEY_ID environment variable not defined\"; exit 1; }[ $AWS_STAGE_NAME != 'none' ] || { echo \"exit because aws stage name is none\"; exit 1; }# 数值比较用下面表达式-eq -ne -gt -lt -ge -le# 字符串比较用下面表达式  = != -z -n使用函数# create hello.sh#! /bin/bashfunction sayhello(){  echo \"Hello,World\"  return 1}. hello.shsayhelloresult=$?echo $result# 函数只能返回 0 到 255 的数值，所以如果想返回字符串的话，需要使用点小技巧绕一下。# 我们可以使用 echo 字符串的方式，输出字符串，然后调用的地方使用`$()`包裹得到需要的信息。function now(){    str=$(date \"+%Y-%m-%d %H:%M:%S\")    echo $str}# Invoke functionn=$(now)echo $n我们也可以使用 $() 去调用其他脚本，比如 $(node xxx.js) 或者 $(python xxx.py) ， 这样可以使用其他的脚本去实现更强的功能，然后返回结果到bash中去。【全文完】"
  },
  
  {
    "title": "Docker 使用整理",
    "url": "/2020/03/docker/",
    "categories": "技术",
    "tags": "bash, shell, docker",
    "date": "2020-03-25 17:44:00 +0800",
    





    
    "snippet": "Docker 简介Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。我们需要将 Docker 和 虚拟机区分一下，虚拟机是模拟了整套的操作系统环境，可以在操作系统里面运行另外一个操作系统。 而 Docker 并没有模拟完整的操作系统，而是对进程进行隔离。 或者说，在正常的进程外面套了一个保护层，对于容器里面的进程来说，他接触到的各种资源都是虚拟，从而实现了于底层系统...",
    "content": "Docker 简介Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。我们需要将 Docker 和 虚拟机区分一下，虚拟机是模拟了整套的操作系统环境，可以在操作系统里面运行另外一个操作系统。 而 Docker 并没有模拟完整的操作系统，而是对进程进行隔离。 或者说，在正常的进程外面套了一个保护层，对于容器里面的进程来说，他接触到的各种资源都是虚拟，从而实现了于底层系统的隔离。因为 Docker 容器是进程级别的，相比于虚拟机，启动快，占用资源少。Docker 安装Docker 有很多版本，这里介绍 docker ce (Community Edition) 的安装。Windows安装包： https://www.docker.com/docker-windows安装文档： https://docs.docker.com/desktop/windows/install/既然 Docker 是基于 Linux 容易的一种封装，那么 Docker Windows 是基于什么呢？ 答案是，基于 Hyper-V 或者 WSL2，这两个实际上会启动 Linux ，然后在此基础上在运行 Docker.Ubuntuhttps://docs.docker.com/engine/install/ubuntu/运行以下命令安装# Uninstall Old Dockersudo apt-get remove docker docker-engine docker.io containerd runc# Update APT-GET Repositorysudo apt-get update# Install packages to allow apt to use a repository over HTTPS:sudo apt-get install apt-transport-https ca-certificates curl software-properties-common# Add Docker’s official GPG key:curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo apt-key fingerprint 0EBFCD88# Set Repositorysudo add-apt-repository \\   \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\   $(lsb_release -cs) \\   stable\"# Install Dockersudo apt-get updatesudo apt-get install docker-ce检查安装是否成功docker version docker infoDocker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组sudo usermod -aG docker $USER基本命令Image 文件Image 文件是 Docker 应用程序的基础，应用程序以及依赖都打包在 Image 里面，只有通过这个文件才能生成 Docker 容器# 列出所有镜像docker image ls# 删除镜像docker image rm [imageName]Docker Run# run hello-worlddocker run hello-world# 本地运行Docker帮助文档 8080 是本地端口， 80是Docker内的端口docker run -d -p 8080:80 docker/getting-started# 运行一个docker 服务器，重定向9080端口到nginx80端口docker run -p 8080:80 nginxdocker run -it -p 8080:80 nginx # 运行nginx，将输出转移到控制台docker run -it --rm -d -p 8080:80 --name web nginx# 运行docker ubuntudocker run -it ubuntu bash# 查询本地运行的Docker进程，会列出Docker运行的进程docker psdocker ps -a # 查出所有的进程，包括已经停止掉得进程，问题，死掉的进程，contianer还在，怎么进去查看分析# 进入某个进程docker exec -it [contianerid] /bin/bashdocker exec -it 68067442d2f9 /bin/bash# 容器运行之后，会生成一个文件，而且关闭容器并不会删除容器文件，只是容器停止运行而已# 列出本机所有容器，包括终止运行的容器docker container ls --all# 进入 docker 进程查所有进程树ps auxwwf# 删掉 docker 进程docker kill [contianerid]# 对于那些不会自动终止的容器，必须使用docker container kill 命令手动终止。docker container kill [containID]Docker Build# 构建一个docker imagesudo docker build -f dockerfile-receiver# 编译当前目录Docker镜像docker build . -t cylin2000/test# 列出本机 imagedocker image ls# 删除本机 imagedocker image rm xxxx# 拉取 hello-world 镜像，因为 library 是默认组，所以可以省略docker image pull library/hello-worldDocker file创建一个文件保存为 Dockerfile# DockerfileFROM nginx:latest# This command will copy index.html from current folder to docker image /usr/share/nginx/html/ folderCOPY ./index.html /usr/share/nginx/html/index.htmlRun following command build and run docker image# docker builddocker build -t my-nginx .# docker run docker run -it --rm -d -p 8080:80 --name web my-nginxDocker Push 到其他 Repositoryhttps://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-docker-cli?tabs=azure-clidocker pull nginx# 注意上面语句等效于下面的语句# docker pull docker.io/library/nginx:latest# 打上TAG，注意TAG里面就包含了你 repository 的地址docker tag nginx &lt;myregistryname&gt;.azurecr.io/calvin/nginx:latest# 登录 docker registry 否则 push 会失败docker login &lt;myregistryname&gt;.azurecr.iodocker push &lt;myregistryname&gt;.azurecr.io/calvin/nginx:latest# 其他备参考docker pull josephinef/enzweb:nginx-php7docker tag josephinef/enzweb:nginx-php7 &lt;myregistryname&gt;.azurecr.io/josephinef/enzweb:nginx-php7docker push &lt;myregistryname&gt;.azurecr.io/josephinef/enzweb:nginx-php7# 如果出现下面错误，注意是否登录成功，是否 sudo 混用了unauthorized: authentication required参考资料https://dockone.io/article/101 https://www.ctolib.com/docs/sfile/docker-practice/etcd/intro.htmlhttps://www.ruanyifeng.com/blog/2018/02/docker-tutorial.htmlhttps://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html【全文完】"
  },
  
  {
    "title": "给 Sublime Text 创建一个 markdeep 插件",
    "url": "/2020/03/sublimetext-markdeep/",
    "categories": "技术",
    "tags": "sublime, markdeep",
    "date": "2020-03-18 17:00:00 +0800",
    





    
    "snippet": "  本文介绍如何创建一个Sublime Text 3的插件，并用这个插件自动预览markdown文件markdeep 简介markdeep 是一个轻巧的markdown解析器，只需要一行代码就可以直接解析本地的markdown文件。使用方法是将md文件改名为html结尾，如 test.md 改成 test.md.html，并且在文件最后面增加如下代码，双击用浏览器打开即可&lt;!-- Ma...",
    "content": "  本文介绍如何创建一个Sublime Text 3的插件，并用这个插件自动预览markdown文件markdeep 简介markdeep 是一个轻巧的markdown解析器，只需要一行代码就可以直接解析本地的markdown文件。使用方法是将md文件改名为html结尾，如 test.md 改成 test.md.html，并且在文件最后面增加如下代码，双击用浏览器打开即可&lt;!-- Markdeep: --&gt;&lt;style class=\"fallback\"&gt;body{visibility:hidden;white-space:pre;font-family:monospace}&lt;/style&gt;&lt;script src=\"markdeep.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://casual-effects.com/markdeep/latest/markdeep.min.js?\"&gt;&lt;/script&gt;&lt;script&gt;window.alreadyProcessedMarkdeep||(document.body.style.visibility=\"visible\")&lt;/script&gt;markdeep 支持很多插件，如,LaTeX,流程图,日历等，非常强大，详细的使用方法参考： https://casual-effects.com/markdeep/但是它有个缺点，就是需要手动将文件名改名为html结尾,这样使用代码编辑器的时候，md的高亮效果就会丢失，且改掉后缀也不是很好的做法。Sublime Text 3 的 markdeep 插件因为我经常使用 Sublime 编辑 markdown 文件，所以希望能够在编辑过程只直接按一个快捷键，或者一个右键菜单，就能快速用markdeep来预览当前文件。   寻找了一下，没有现成的插件，所以决定自己写一个，开发步骤如下：  创建插件文件打开Sublime Text 3, 选择 Tools -&gt; Developer -&gt; New Plugin … 菜单，系统会自动创建如下文件import sublimeimport sublime_pluginclass ExampleCommand(sublime_plugin.TextCommand):\tdef run(self, edit):\t\tself.view.insert(edit, 0, \"Hello, World!\")将文件修改为下面内容，为了加速我把markdeep.min.js部署到了七牛云上import sublimeimport sublime_pluginimport tempfileimport webbrowserclass MarkdeepPreviewCommand(sublime_plugin.TextCommand):\tdef run(self, edit):\t\t# get all contents from current view\t\tcontents = self.view.substr(sublime.Region(0, self.view.size()))\t\t# save to temp file\t\ttempfilename = tempfile.mkstemp(\".html\")\t\tf = open(tempfilename[1], 'w')\t\tf.write(contents)\t\tf.write('&lt;!-- Markdeep: --&gt;&lt;style class=\"fallback\"&gt;body{visibility:hidden;white-space:pre;font-family:monospace}&lt;/style&gt;&lt;script src=\"https://public.caiyunlin.com/markdeep.min.js\"&gt;&lt;/script&gt;&lt;script&gt;window.alreadyProcessedMarkdeep||(document.body.style.visibility=\"visible\")&lt;/script&gt;')\t\tf.close()\t\twebbrowser.open(tempfilename[1])这里稍微解释一下，首先就是 MarkdeepPreviewCommand 这个class，插件系统会自动将这个驼峰命名解析为 markdeep_preview 的 command, 这个command在后面菜单和快捷键的地方会用到。代码内容比较简单，就是获取当前编辑器的所有内容，然后追加一个markdeep的脚本信息，保存到临时文件，最后用默认浏览器打开。有关Sublime Text 3的插件API，可以参考这里 https://www.sublimetext.com/docs/api-reference中文翻译： https://www.oschina.net/translate/sublime-text-plugin-api-reference将文件内容保存到Sublime Text 3的Packges路径下，如 sublime\\Data\\Packages\\MarkDeep\\main.py 这里是创建MarkDeep目录，并且将脚本保存为main.py，系统会自动加载  创建右键菜单在MarkDeep目录下面，创建 Context.sublime-menu 文件，内容如下，这里的command就是对应第一个脚本的名称[\t{ \"caption\": \"-\" },\t{\t\t\"caption\": \"MarkDeep Preview\",\t\t\"command\" : \"markdeep_preview\"\t}]  绑定快捷键，这里是绑定了F12键在MarkDeep目录下面，创建 Default (Windows).sublime-keymap 文件，如果要支持Mac系统，则创建 Default (OSX).sublime-keymap，Linux系统，则是 Default (Linux).sublime-keymap[     { \"keys\": [\"f12\"], \"command\": \"markdeep_preview\" } ]   测试，新建一个md文件，如 test.md，黏贴以下内容，右键选择 “Markdeep Preview”，或者直接按 F12 键，预览一下吧！**Example**Welcome to Markdeep. It's the simple way to write plain text with _style_.                          **************************************                _______            ** .-------.     /      /   .-----.  ** | Write +-+-&gt;/ Edit ++-&gt;| Share | ** '-------' ^ /______/ |   '-----'  **           |          |            **            '--------'             **************************************1. Write a text document2. Add the Markdeep line at the end3. Save with file extension `.md.html`4. Double-click to view**Notes**!!!    I'm a note. Don't mind me, I'm just sitting here.!!!    I'm a note. Don't mind me, I'm just sitting here.!!! note    Another note.!!! Tip    Close the door on the way out.!!! WARNING    I'm a warning, perhaps. *Something might happen!*!!! ERROR: Seriously    Watch out, something **bad** could happen.    This is still more error text.Learn more athttps://casual-effects.com/markdeep【全文完】"
  },
  
  {
    "title": "Sublime Text 使用小结",
    "url": "/2020/03/sublimetext/",
    "categories": "技术",
    "tags": "sublime",
    "date": "2020-03-18 17:00:00 +0800",
    





    
    "snippet": "Sublime Text 简介Sublime Text 是一个轻量、简洁、高效、跨平台的编辑器。 它启动速度快，颜值高，对各类变成语言都有很好的支持。Sublime Text 使用技巧竖行选择首先将光标移到要操作内容的第一行，按住 Shift 键，再按住鼠标右键，往下拖动，就可以出现多个光标。 此时，再输入文字，或者做其他操作，都会在多行同时执行。 可以使用下面文字做测试，如：将 class...",
    "content": "Sublime Text 简介Sublime Text 是一个轻量、简洁、高效、跨平台的编辑器。 它启动速度快，颜值高，对各类变成语言都有很好的支持。Sublime Text 使用技巧竖行选择首先将光标移到要操作内容的第一行，按住 Shift 键，再按住鼠标右键，往下拖动，就可以出现多个光标。 此时，再输入文字，或者做其他操作，都会在多行同时执行。 可以使用下面文字做测试，如：将 class1 替换改成 class2&lt;ul&gt;\t&lt;li class=\"class1\"&gt;1&lt;/li&gt;\t&lt;li class=\"class1\"&gt;2&lt;/li&gt;\t&lt;li class=\"class1\"&gt;3&lt;/li&gt;\t&lt;li class=\"class1\"&gt;4&lt;/li&gt;\t&lt;li class=\"class1\"&gt;5&lt;/li&gt;\t&lt;li class=\"class1\"&gt;6&lt;/li&gt;&lt;/ul&gt;开启 ShellSublime 自带的 shell ，可以使用 ctrl+` 唤起，但是它是基于 Python 的，不能运行其他 cmd, powershell 等命令。是否可以像 VS Code 那样，自带 cmd 或者 powershell 的 shell 呢，答案是可以的，方法如下。      安装 Package Control 如果你没有安装过 Package Control, 按下 Ctrl+Shift+P， 在输入框中输入 Package Control, 然后选中 Install Package Control, 回车确认        安装 Terminus Package Control 安装好之后，再次按下 Ctrl+Shift+P，在输入框中输入 Install Package, 选中 Package Control : Install Package, 回车 在弹出的窗口中，搜索 Termius 回车安装    配置快捷键选中菜单 Preferences -&gt; Package Settings -&gt; Terminus -&gt; Key bindings 在弹出的 json 中，输入以下快捷键配置，保存    { \"keys\": [\"ctrl+`\"], \"command\": \"toggle_terminus_panel\" }        按下 Ctrl + ` 则会弹出 cmd 的 shell， 在其中输入 powershell 就会进入到 PowerShell    Sublime Text 插件          All Autocomplete　　Sublime Text 默认的 Autocomplete 功能只考虑当前的文件，而 AllAutocomplete 插件会搜索所有打开的文件来寻找匹配的提示词。      Terminus 可以像VSCode那样打开真正的控制台      SFTP 可以将本地文件快速同步到远程服务器，支持 ftp,sftp,ftps 等      MarkdownPreview 快速预览 Markdown 文件      LiveReload 配合 Markdown Preview 自动刷新预览的 Markdown 文件      ImagePaste 可以粘贴剪贴板图片到 markdown 文件所在的图片文件夹      Sublime Text 开启 Markdown 预览  使用组合键 Ctrl+Shift+P 调出命令面板  输入 Install Package ，选中 Package Control : Install Package, 回车 在弹出的窗口中，搜索 MarkdownPreview 回车安装  安装完成之后，再次按 Ctrl+Shift+P，输入 Markdown Preview 找到并选中Markdown Preview： Preview in Browser  界面出现三个选项：github,gitlab和markdown。任选其一即可，github/gitlab是利用他们的在线API来解析.md文件，支持在线资源的预览，如在线图片它的解析速度取决于你的联网速度。markdown就是传统的本地打开，不支持在线资源的预览。  按回车，会在默认浏览器中显示预览结果注意此时 Markdown 的预览是静态的，如果需要自动预览还需要再安装一下 LiveReload 插件  按下 Ctrl+Shift+p, 输入 Install Package，输入 LiveReload, 回车安装  安装成功后, 再次 Ctrl+shift+p, 输入 LiveReload: Enable/disable plug-ins, 回车, 选择 Simple Reload with delay (400ms) 或者 Simple Reload，两者的区别在于后者没有延迟。默认 MarkdownPreview 的 enable_autoreload 设置是 true 的，如果没有，参考下面步骤设置一下打开其配置文件 Preferences -&gt; Package Settings -&gt; Markdown Preview -&gt; Settings，在右侧栏加一条下面这个自定义参数，然后重启 Sublime:{    \"enable_autoreload\": true}Sublime Text 常用快捷键  ctrl+shift+n 打开新Sublime  ctrl+shift+w 关闭Sublime，关闭所有打开文件  ctrl+shift+t 重新打开最近关闭文件  ctrl+n 新建文件  ctrl+s 保存  ctrl+shift+s 另存为  ctrl+f4 关闭文件  ctrl+w 关闭  ctrl+k, ctrl+b 切换侧边栏显示状态  f11 切换全屏状态  shift+f11 免打扰模式状态切换  backspace 删除左侧  shift+backspace 左侧删除  ctrl+shift+backspace 左侧全部删除  delete 右侧删除  enter 插入  shift+enter 插入  ctrl+z 撤消  ctrl+shift+z 重做  ctrl+y 重做或重复  ctrl+u 软撤消  ctrl+shift+u 软重做  ctrl+shift+v 粘贴并格式化  shift+delete 剪切  ctrl+insert 拷贝  shift+insert 粘贴  shift+left 移动并选择  shift+right 移动并选择  shift+up 移动并选择  shift+down 移动并选择  ctrl+left 按\\w规则移动（跳跃）  ctrl+right 按\\w规则移动（跳跃）  ctrl+shift+left 按\\w规则移动并选择Sublime Text 设置按下 Preferences -&gt; Settings 菜单，可以打开 Sublime Text 的用户设置，下面是我配置的一些默认设置：{\t// 设置Sans-serif（无衬线）等宽字体，以便阅读\t\"font_face\": \"YaHei Consolas Hybrid\",\t// 字体大小\t\"font_size\": 12,\t// 使光标闪动更加柔和\t\"caret_style\": \"phase\",\t// 高亮当前行\t\"highlight_line\": true,\t// 高亮有修改的标签\t\"highlight_modified_tabs\": true,\t// 主题设置\t\"theme\": \"Default.sublime-theme\",\t\"color_scheme\": \"Packages/Color Scheme - Default/Monokai.sublime-color-scheme\",\t// Sublime Merge\t\"sublime_merge_path\": \"SublimeMerge/sublime_merge.exe\"}【全文完】"
  },
  
  {
    "title": "在 Ubuntu 上安装配置 PHP 环境",
    "url": "/2018/08/install-php-on-ubuntu/",
    "categories": "技术",
    "tags": "ubuntu, php",
    "date": "2018-08-01 17:00:00 +0800",
    





    
    "snippet": "原有的服务器快到期了，趁活动搞了个阿里云的Ubuntu主机，所以将一些测试的php代码移到这台主机下，下面记录一下在阿里云的Ubuntu上安装php环境的步骤。系统概况  OS : Ubuntu 18.04  Web服务器 : Apache2  PHP : PHP 7.0 +  数据库 : Mysql 5.6 +安装 Apache2 &amp; PHP# 更新apt-get安装源sudo a...",
    "content": "原有的服务器快到期了，趁活动搞了个阿里云的Ubuntu主机，所以将一些测试的php代码移到这台主机下，下面记录一下在阿里云的Ubuntu上安装php环境的步骤。系统概况  OS : Ubuntu 18.04  Web服务器 : Apache2  PHP : PHP 7.0 +  数据库 : Mysql 5.6 +安装 Apache2 &amp; PHP# 更新apt-get安装源sudo apt-get update # 安装Apache2sudo apt-get install apache2 # 安装php7.0sudo apt-get install php7.0 # 查看安装的php版本，命令行指定的是7.0，系统可能是安装7.0或以上某个稳定版本，如 7.2php -v # 查看apache支持php的扩展apt-cache search libapache2-mod-php # 选择安装一个php扩展，这里是 libapache2-mod-php7.2sudo apt-get install libapache2-mod-php7.2 配置PHP  切换到web根目录，创建 phpinfo.phpcd /var/www/htmlsudo vim phpinfo.php   输入以下内容，保存退出&lt;?php    phpinfo();?&gt;      在浏览器访问 https://ipaddress/phpinfo.php 查看 php.ini 所在的路径 如：/etc/php/7.2/apache2/php.ini        修改 php.ini ，找到下面两行，去掉前面的分号开启对应扩展  extension=mbstringextension=pdo_mysql  重启Apache2sudo /etc/init.d/apache2 restart 安装MYSQL# 安装mysql服务sudo apt-get install mysql-server # 检查mysql的版本mysql -V 设置MYSQL密码安装mysql的时候，可能没有让用户输入root的密码，通过下面方式重置  进入到etc/mysql 目录下，查看debian.cnf文件sudo vim /etc/mysql/debian.cnf  找到用户名，密码 ，使用此账号登录mysql，示例如下# 用户名：debian-sys-maint# 密码：xedvSNKdLavjuEWVsudo mysql -udebian-sys-maint -pxedvSNKdLavjuEWV  修改root用户的的密码-- mysql 8.0 之前版本执行下面语句-- 这里是关键点，由于mysql5.7没有password字段，密码存储在authentication_string字段中，password()方法还能用-- 在mysql中执行下面语句修改密码，注意先把`新密码`改成你自己的密码mysql&gt; show databases;mysql&gt; use mysql;mysql&gt; update user set authentication_string=PASSWORD(\"新密码\") where user='root';mysql&gt; update user set plugin=\"mysql_native_password\";mysql&gt; flush privileges;mysql&gt; quit;-- 如果是8.0之后的mysql版本，用下面语句修改密码mysql&gt; show databases;mysql&gt; use mysql;mysql&gt; ALTER USER '用户名'@'localhost' IDENTIFIED WITH mysql_native_password BY '新密码';mysql&gt; flush privileges;   --刷新MySQL的系统权限相关表mysql&gt; exit;  修改完密码，需要重启mysqlsudo /etc/init.d/mysql restart;  再次登录mysql -uroot -p密码安装phpmyadmin  安装phpmyadmin并链接到web目录cd /var/www/html#安装phpmyadminsudo apt-get install phpmyadmin #将安装路径的phpmyadmin和web目录链接起来sudo ln -s /usr/share/phpmyadmin phpmyadmin   因为PHP7.2对类型检查更严格，默认安装的phpmyadmin有些bug需要修改一下，否则会经常在界面抛出warning# 修正点击表格之后的 count Parameter warning的错误sudo vim /usr/share/phpmyadmin/libraries/sql.lib.php # 将 (count($analyzed_sql_results['select_expr'] == 1) 改为，注意括号位置#    (count($analyzed_sql_results['select_expr']) == 1sudo vim /usr/share/phpmyadmin/libraries/display_import.lib.php   增加PHPMYADMIN的SESSION超时时间PHPMYADMIN的SESSION超时时间默认是1440秒，即24分钟，不方便调试，下面将超时时间改大# 增加phpmyadmin的超时时间sudo vim /usr/share/phpmyadmin/libraries/config.default.php # 修改 $cfg['LoginCookieValidity'] = 1440;# 将1440修改成更大的值即可。 如 86400 是24小时# 同步修改php.ini session时间sudo vim /etc/php/7.2/apache2/php.inisession.gc_maxlifetime = 86400  重启Apache2使配置生效sudo /etc/init.d/apache2 restart MYSQL 执行错误排查  数据库错误发生  General error: 1267 Illegal mix of collations (utf8mb4_general_ci,IMPLICIT) and (utf8mb4_0900_ai_ci….出现改错误是因为 MySQL 默认的 collations 和 表格对应的 collations 不一致导致的，需要将默认的设置为 utf8mb4_general_ci，步骤如下# 登录 mysqlsudo mysql -uUSERNAME -pPASSWORDmysql&gt; show variables where Variable_name like 'collation%';# 系统会显示类似如下界面，其中 Value 根据你原始设置可能略有不同+----------------------+--------------------+| Variable_name        | Value              |+----------------------+--------------------+| collation_connection | utf8mb4_0900_ai_ci || collation_database   | utf8mb4_0900_ai_ci || collation_server     | utf8mb4_0900_ai_ci |+----------------------+--------------------+# 执行下面脚本mysql&gt; set collation_connection=utf8mb4_general_ci;#Query OK, 0 rows affected (0.00 sec)mysql&gt; set collation_database=utf8mb4_general_ci;#Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; set collation_server=utf8mb4_general_ci;#Query OK, 0 rows affected (0.00 sec)# 再次查询验证结果mysql&gt;  show variables where Variable_name like 'collation%';+----------------------+--------------------+| Variable_name        | Value              |+----------------------+--------------------+| collation_connection | utf8mb4_general_ci || collation_database   | utf8mb4_general_ci || collation_server     | utf8mb4_general_ci |+----------------------+--------------------+这时已经默认的 collation 也设置为 utf8mb4_general_ci 了，如果phpmyadmin查询表格和字段也被设置其他的 collation ，可以使用下面语句生成批量脚本来替换# 注意此处 原始 collation 是 utf8mb4_0900_ai_ci 目标是 utf8mb4_general_ci# 需要操作的数据库为 【数据库名】，修改语句执行后，复制 修正SQL 那一列的记过再次去mysql执行即可SELECT TABLE_SCHEMA '数据库',TABLE_NAME '表',COLUMN_NAME '字段',CHARACTER_SET_NAME '原字符集',COLLATION_NAME '原排序规则',CONCAT('ALTER TABLE ', TABLE_SCHEMA,'.',TABLE_NAME, ' MODIFY COLUMN ',COLUMN_NAME,' ',COLUMN_TYPE,' CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;') '修正SQL' FROM information_schema.`COLUMNS` WHERE COLLATION_NAME RLIKE 'utf8mb4_0900_ai_ci' and TABLE_SCHEMA = '【数据库名】'注意在phpmyadmin，勾选完整内容，才会显示完整的sql语句迁移域名此步骤可选，如果你直接用ip地址访问，就不需要配置这一步。以域名 www.example.com 为例，现将域名A记录解析到主机的ip地址，此时访问会显示默认网站。这里配置到专门的目录，注意替换下面 www.example.com 为你的实际域名。# 进入 /var/www, 创建 www.example.com 目录mkdir /var/www/www.example.comecho \"hello world!\" &gt; /var/www/www.example.com/index.html# 进入 /etc/apache2/sites-available 目录cd /etc/apache2/sites-available/# 拷贝默认的定义文件作为模板sudo cp 000-default.conf www.example.com.confsudo nano www.example.com.conf  # 修改www.example.com.conf添加如下内容    ServerName www.example.com    ServerAdmin webmaster@localhost    DocumentRoot /var/www/www.example.com/# 进入 /etc/apache2/sites-enabled 目录，创建链接sudo ln -s /etc/apache2/sites-available/www.example.com.conf www.example.com.conf# 重启Apache2sudo /etc/init.d/apache2 restart后续域名解析到本机ip地址，并且将文件上传到 /var/www/www.example.com/ 目录即可【全文完】"
  },
  
  {
    "title": "如何在 JavaScript 中使用 Async Await",
    "url": "/2018/05/javascript-async-await/",
    "categories": "技术",
    "tags": "javascript",
    "date": "2018-05-06 17:00:00 +0800",
    





    
    "snippet": "JavaScript 是一个同步的单线程执行的语言，这意味着，JS代码是从头到挨着顺序执行的，这肯定跟我们大多数多JS开发的人心里的想法不符，因为写JS需要很多异步操作，包括请求网络资源(Web)，本地文件资源(NodeJS)，甚至异步的逻辑写太多了，以至于出现回调地狱，而JS也提出了Promise, Async Await等方法来避免回调地狱。复习JavaScript的回调机制做一个小实验...",
    "content": "JavaScript 是一个同步的单线程执行的语言，这意味着，JS代码是从头到挨着顺序执行的，这肯定跟我们大多数多JS开发的人心里的想法不符，因为写JS需要很多异步操作，包括请求网络资源(Web)，本地文件资源(NodeJS)，甚至异步的逻辑写太多了，以至于出现回调地狱，而JS也提出了Promise, Async Await等方法来避免回调地狱。复习JavaScript的回调机制做一个小实验，如果你的浏览器是Chrome内核的，可以直接按F12打开开发者工具，首先执行一下需要的辅助函数function write_log(str){    var now = new Date();    var log = now.getHours()+\":\"+now.getMinutes()+\":\"+now.getSeconds()+\" \"+str;    console.log(log);}然后输入下面一段脚本执行write_log(\"hello\")setTimeout(function(){    write_log(\"great\")},2000)write_log(\"world\");我们会看到 系统顺序输出了 hello,world 并且在两秒后输出了 great ， 那既然是同步的为什么不是依次输出 hello, 然后隔两秒输出 great 最后再输出 world 呢？这里需要了解一下JS的执行机制，JS在顺序执行的时候，有一个主线程自顶而下依次执行，当它遇到耗时的异步操作，比如此处的setTimeout 或者其他ajax请求等，会给他分配一个编号，并且放到队列里面然后去执行(此处的执行可能是JS引擎分配的一个新线程去执行，和JS的主线程无关)，然后主线程在执行完当前所有代码之后，会去队列里面查看分配出去的任务有没有执行完毕，如果完成了，则调用其定义的回调代码，这样就完成了一个异步操作。下图可以说明这个运行机制，至始自终只有一个主线程在不停的轮询我们再用一段代码来测试一下//强制sleepfunction sleep(numberMillis) {    var now = new Date();    var exitTime = now.getTime() + numberMillis;    while (true) {        now = new Date();        if (now.getTime() &gt; exitTime){            return;            }    }}write_log(\"hello\")setTimeout(function(){    write_log(\"great\")},2000)write_log(\"world\")sleep(5000);观察结果，我们发现great并不是在2秒之后输出的，而是在5秒之后，那是因为，主线程在sleep里面循环了5秒钟之后才有机会去检查回调队列里面的事件，才有机会执行 write_log(\"great\") 这句脚本。回调地狱的由来如果是在网页端写一些代码，异步的操作主要是访问后台service, 下面是一段封装的示例代码，call_svc是调用后台服务，传入 data 并且得到 result, 这里还没有做异常处理。    call_svc(serviceUrl, data, function(result){        //do someing    });【全文完】"
  },
  
  {
    "title": "Javascript 对象继承",
    "url": "/2018/04/javascript-inherit/",
    "categories": "技术",
    "tags": "javascript",
    "date": "2018-04-28 19:16:45 +0800",
    





    
    "snippet": "Javascript 没有直接的对象继承，可以通过原型继承的方式来实现，下面是一种实现方法。定义父类将方法写到原型（prototype)上function Person(name, age) {  this.name = name;  this.age = age;};Person.prototype.greeting = function() {  console.log('Hi! I\\'...",
    "content": "Javascript 没有直接的对象继承，可以通过原型继承的方式来实现，下面是一种实现方法。定义父类将方法写到原型（prototype)上function Person(name, age) {  this.name = name;  this.age = age;};Person.prototype.greeting = function() {  console.log('Hi! I\\'m ' + this.name + '.');};定义子类function Teacher(name, age, title) {  //初始化父类的属性  Person.call(this, name, age);  //Person.apply(this,[name,age]);  //初始化子类的属性  this.title = title}//继承父类的方法Teacher.prototype = Object.create(Person.prototype);//将构造器指回Teacher，一般情况下可省略，详见 https://stackoverflow.com/questions/8453887/why-is-it-necessary-to-set-the-prototype-constructorTeacher.prototype.constructor = Teacher;//设置子类的方法Teacher.prototype.sayHello = function(){   console.log('Hi! I\\'m ' + this.name + '. My title is '+this.title);}实例化var teacher1 = new Teacher('Allen',35,'title1')teacher1.sayHello();var teacher2 = new Teacher('Bob',35,'title1')teacher1.greeting();【全文完】"
  },
  
  {
    "title": "一个简便的 Excel 导出方案",
    "url": "/2018/04/export-excel/",
    "categories": "技术",
    "tags": "javascript, excel, php",
    "date": "2018-04-15 17:16:45 +0800",
    





    
    "snippet": "导出Excel是开发中遇到的一个常见需求，但是不同的后端服务程序可能需要引入不同的类库，比如PHP需要PHPExcel，C#需要Office组件或者其他第三方Excel解析类。 对于简单的表格数据导出，这里提供另外一个思路，可以不需要引入第三方类库来解决Excel的导出问题。数据展示导出Excel文件之前，一般我们会展示数据，通常是使用表格,示例如下：            姓名      ...",
    "content": "导出Excel是开发中遇到的一个常见需求，但是不同的后端服务程序可能需要引入不同的类库，比如PHP需要PHPExcel，C#需要Office组件或者其他第三方Excel解析类。 对于简单的表格数据导出，这里提供另外一个思路，可以不需要引入第三方类库来解决Excel的导出问题。数据展示导出Excel文件之前，一般我们会展示数据，通常是使用表格,示例如下：            姓名      手机      性别      年龄      邮箱                  张三      13344445555      男      25      zhangsan@163.com              李四      13366665555      男      26      lisi@163.com      这种表格一般都是使用 table 标签生成，其实Excel本身也是可以解析这种标签格式的，所以我们将如下表格对应的HTML代码保存到本地文件，并且将扩展名改成 xls，然后用Excel打开即可正常解析。&lt;table&gt;    &lt;thead&gt;        &lt;tr&gt;            &lt;th width=\"20%\"&gt;姓名&lt;/th&gt;            &lt;th width=\"20%\"&gt;手机&lt;/th&gt;            &lt;th width=\"20%\"&gt;性别&lt;/th&gt;            &lt;th width=\"20%\"&gt;年龄&lt;/th&gt;            &lt;th width=\"20%\"&gt;邮箱&lt;/th&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;            &lt;tr&gt;                &lt;td&gt;张三&lt;/td&gt;                &lt;td&gt;13344445555&lt;/td&gt;                &lt;td&gt;男&lt;/td&gt;                &lt;td&gt;25&lt;/td&gt;                &lt;td&gt;zhangsan@163.com&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;李四&lt;/td&gt;                &lt;td&gt;13366665555&lt;/td&gt;                &lt;td&gt;男&lt;/td&gt;                &lt;td&gt;26&lt;/td&gt;                &lt;td&gt;lisi@163.com&lt;/td&gt;            &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;封装导出功能既然Excel有解析HTML table的功能，我们就可以把数据直接导出html格式，下面用php代码示例一下导出步骤  在导出的处理程序里设置对应excel的header这样用户访问到这个页面是，会弹出XLS的文件下载框，其中ExportAll为文件名,可以替换成自己需要的文件名header('pragma:public');header('Content-type:application/vnd.ms-excel;charset=utf-8;name=\"ExportAll.xls\"');header(\"Content-Disposition:attachment;filename=ExportAll.xls\");  页面模板输出如下格式&lt;html xmlns:v=\"urn:schemas-microsoft-com:vml\" xmlns:o=\"urn:schemas-microsoft-com:office:office\" xmlns:x=\"urn:schemas-microsoft-com:office:excel\" xmlns=\"https://www.w3.org/TR/REC-html40\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;    &lt;thead&gt;        &lt;tr&gt;            &lt;th width=\"20%\"&gt;姓名&lt;/th&gt;            &lt;th width=\"20%\"&gt;手机&lt;/th&gt;            &lt;th width=\"20%\"&gt;性别&lt;/th&gt;            &lt;th width=\"20%\"&gt;年龄&lt;/th&gt;            &lt;th width=\"20%\"&gt;邮箱&lt;/th&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;        &lt;tr&gt;            &lt;td&gt;张三&lt;/td&gt;            &lt;td&gt;13344445555&lt;/td&gt;            &lt;td&gt;男&lt;/td&gt;            &lt;td&gt;25&lt;/td&gt;            &lt;td&gt;zhangsan@163.com&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;李四&lt;/td&gt;            &lt;td&gt;13366665555&lt;/td&gt;            &lt;td&gt;男&lt;/td&gt;            &lt;td&gt;26&lt;/td&gt;            &lt;td&gt;lisi@163.com&lt;/td&gt;        &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;小结本文的思路是利用Excel本身强大的兼容解析功能,将解析放在Excel客户端，而不是在服务器生成复杂的xls格式的数据。 对简单的Excel导出需求，这样可以简化开发，加快开发的进度。【全文完】"
  },
  
  {
    "title": "微信跳一跳-物理外挂",
    "url": "/2018/01/wechat-jump-jump/",
    "categories": "技术",
    "tags": "wechat",
    "date": "2018-01-26 02:00:00 +0800",
    





    
    "snippet": "微信最近在微信发布了跳一跳游戏，很是流行，朋友圈很多人都在玩。好奇之余，我也打了很多把，无奈没有天赋，分数排名总是很低，查询别人打高分的技巧，不小心发现了歪路，哈哈。物理外挂起初我是看到，有人使用安卓手机，监测屏幕，计算两个物体的中心坐标，然后使用 adb 调试安卓手机，模拟点击屏幕达到跳跃的效果，因为按压时间是通过距离测算出来的，所以非常精确。但是我用的 iPhone 手机，前面的步骤都可...",
    "content": "微信最近在微信发布了跳一跳游戏，很是流行，朋友圈很多人都在玩。好奇之余，我也打了很多把，无奈没有天赋，分数排名总是很低，查询别人打高分的技巧，不小心发现了歪路，哈哈。物理外挂起初我是看到，有人使用安卓手机，监测屏幕，计算两个物体的中心坐标，然后使用 adb 调试安卓手机，模拟点击屏幕达到跳跃的效果，因为按压时间是通过距离测算出来的，所以非常精确。但是我用的 iPhone 手机，前面的步骤都可以完成，最后一步操作手机按压没法去模拟，正好我手头有个树莓派，我寻思是不是能用树莓派来控制一个硬件去直接点击屏幕，来完成点击效果呢，想着查了一下，没想到真有人做，而且也实现了。感觉很有意思，而且我买的树莓派一直没派上什么实际用场，我决定拿来玩一玩，来做一个物理外挂。使用原件  树莓派  舵机  面包板  橙子（用于导电）  一小块海绵实现思路  首先将 iPhone 接入连上电脑，下载一个 iPhone 屏幕同步软件，可以使用 iTools  然后在屏幕上截取手机图片，根据两个物体的中点，计算两个物体间的距离，此部分的代码可以参考 https://github.com/wangshub/wechat_jump_game 并且将距离信息转换为时间长短信息发送给树莓派  树莓派驱动舵机转动一定的角度停留设置的时间，完成按压  因为直接的物体按压到手机屏幕并不能模拟点击的效果，这里用一个橙子插入导线，导线下方在手机上放一块湿的海绵，就可以模拟人体的生物电完成点击  按压一次完成后，重复第3步的操作，直至游戏结束，目前测试可以玩到1000+的分数，应该可以更多因为树莓派刷机过一次，这部分代码没有备份，竟然丢了，还好当时录下了一个视频，留个纪念吧\t后记这个物理外挂当然不会被封掉，因为它是实际操控手机屏幕完成的，没有启用机器debug，也没有操作任何手机进程。不过后果就是，有了游戏的外挂，游戏就不好玩了，刷了几天第一，就再也没玩过这个跳一跳游戏，外挂果然毁游戏啊。"
  },
  
  {
    "title": "搭建本地的 Jenkins 持续集成系统",
    "url": "/2017/12/install-jenkins/",
    "categories": "技术",
    "tags": "jenkins",
    "date": "2017-12-03 21:50:20 +0800",
    





    
    "snippet": "这篇文章简要介绍如何在本地搭建一套Jenkins持续集成系统。基本实现是这样的  在虚拟机中安装一套Ubuntu系统  在Ubuntu中，安装Jenkins 和 Docker  在Jenkins中配置Job，从GitHub获取代码，并且自动Docker实例，运行测试，编译和部署，之后销毁Docker实例基础环境该系统选择的基础环境是 Ubuntu 操作系统，所以务必先准备好Ubuntu，推荐...",
    "content": "这篇文章简要介绍如何在本地搭建一套Jenkins持续集成系统。基本实现是这样的  在虚拟机中安装一套Ubuntu系统  在Ubuntu中，安装Jenkins 和 Docker  在Jenkins中配置Job，从GitHub获取代码，并且自动Docker实例，运行测试，编译和部署，之后销毁Docker实例基础环境该系统选择的基础环境是 Ubuntu 操作系统，所以务必先准备好Ubuntu，推荐版本是16.04，这个不是最新的版本，但是是长期支持的稳定版本。本地虚拟机可以到官网下载 Ubuntu 16.04 Server 版本镜像。https://releases.ubuntu.com/16.04/ubuntu-16.04.6-server-amd64.iso注意：安装Ubuntu的时候，请选择安装组件 LAMP 和 SSH Server安装 JenkinsUbuntu准备好了后，我们就可以直接登录系统，开始安装Jenkins了参考官方WIKI：https://wiki.jenkins.io/display/JENKINS/Installing+Jenkins+on+Ubuntu执行下面脚本# 添加Jenkins的Global Key到APT中wget -q -O - https://jenkins-ci.org/debian/jenkins-ci.org.key | sudo apt-key add - # 更新APT库，安装Jenkinssudo sh -c 'echo deb https://pkg.jenkins-ci.org/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list'  sudo apt-get update  sudo apt-get install jenkins  启动 Jenkinssudo service jenkins start  # 停止sudo service jenkins stop# 相关路径# 访问路径：https://localhost:8080  # 安装路径：/var/lib/jenkins  # 日志路径：/var/log/jenkins  配置 Jenkins  在浏览器访问Jenkins地址，注意使用正确的ip地址，可以使用ifconfig查出地址， 如 https://192.168.0.101:8080  在登录页面会需要你输入admin的password，使用下面命令获的密码，输入密码cat /var/jenkins_home/secrets/initialAdminPassword  点击继续，在选择插件界面，选择 Install suggested Plugins  插件安装完毕之后，配置登录的管理员 用户名和密码  配置完成安装 Docker我们期望 Jenins 的Deployment Pipeline 运行在Docker里面，所以需要安装一下 Docker# 清理旧版 dockersudo apt-get remove docker docker-engine docker.io# 更新 APT-GET 库准备安装 一些前置软件sudo apt-get update# 安装HTTPS传输,CURL等软件sudo apt-get install apt-transport-https ca-certificates curl software-properties-common# 添加 Docker’s official GPG key:curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo apt-key fingerprint 0EBFCD88# Set Docker 安装库sudo add-apt-repository \\   \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\   $(lsb_release -cs) \\   stable\"# 安装Dockersudo apt-get updatesudo apt-get install docker-ce运行 Dockersudo docker run hello-worldsudo docker build -f dockerfile-receiversudo docker run -p 9080:80 nginxsudo docker run -it 9080:80 nginx设置 Jenkins 运行 Docker的权限# 如果还没有 docker group 就添加一个：sudo groupadd docker# 将当前用户和jenkins用户加入该 group 内。然后退出并重新登录就生效啦。sudo gpasswd -a ${USER} dockersudo gpasswd -a jenkins docker# 重启 docker 服务sudo service docker restart# 切换当前会话到新 groupnewgrp docker# 重启 jenkins 服务sudo service jenkins restart  至此 Jenkins 环境就搭建好了配置 Jenkins Pipeline下面尝试配置一个Jenkins的Pipeline，测试一下部署流程，基本模拟步骤如下：  创建一个Jenkins Pipeline  Pipeline中使用远程代码库中的Jenkinsfile在指定部署内容  编写提交Jenkinsfile准备代码库  去GitHub上面创建一个测试代码库，如jenkins-test,可以参考 https://github.com/cylin2000/jenkins-test  代码库里面创建 Jenkinsfile 文件，内容是json格式的定义，如下:pipeline {    agent {     \tdocker {    \t\timage  'node:6.3'    \t\targs '-v $HOME/.n63:/root/.n63 -u root:root'    \t}     }     stages {        stage('Example Build') {            steps {                sh 'npm --version'            }        }    }}这个Job很简单，定义了使用docker的node 6.3版本的image 作为 build 的容器，build开始的时候，执行 npm –version 就可以显示npm的版本，注意运行Jenkins的主机不需要安装nodejs的注意 args 中的 -u root:root 一定要有，否则会出现 steps 里面的命令，如 npm install 之类的命令没有权限运行      代码提交之后，就回到Jenkins界面，选择”New Item”，填入名称 如 “HelloPipeline” 选择 “Pipeline”，点击”OK”        在Pipeline配置界面里，”Definition”选择”Pipeline script from SCM”,”SCM”选择 “Git”, 然后填入你的Repository地址，最后点击下面的 “Save” 按钮  【全文完】"
  },
  
  {
    "title": "微信小程序TLS大于等于1.2版本的问题解决",
    "url": "/2017/07/wechat-tls/",
    "categories": "技术",
    "tags": "",
    "date": "2017-07-02 15:00:00 +0800",
    





    
    "snippet": "问题描述使用Windows官网提供的开发端载入Windows小程序，设置了自己架设的php后台服务器程序，显示如下错误解决方法关于TLS的支持，先去微软官网查询一下，Windows对2008R2以下的版本是不支持TLS1.2的，所以xp 2003的系统就不用折腾了。如果你的系统是Windows 2008 R2 或以上的，可以使用以下网址测试一下你搭好的服务器（需要几分钟时间）https://...",
    "content": "问题描述使用Windows官网提供的开发端载入Windows小程序，设置了自己架设的php后台服务器程序，显示如下错误解决方法关于TLS的支持，先去微软官网查询一下，Windows对2008R2以下的版本是不支持TLS1.2的，所以xp 2003的系统就不用折腾了。如果你的系统是Windows 2008 R2 或以上的，可以使用以下网址测试一下你搭好的服务器（需要几分钟时间）https://www.ssllabs.com/ssltest/index.html 查询后大家可以在下面看到自己服务器支持的TLS版本，大部分都是只支持1.0当大家查询到自己服务器不支持1.1、1.2后，可以下载下面网址的软件 IISCrypto.exe ，进行配置 https://www.pianyissl.com/support/page/60选择 Best Practice ，再点击 Apply， 搞定。【全文完】"
  },
  
  {
    "title": "微信使用 JSSDK 分享 OAuth 链接的问题",
    "url": "/2017/06/wechat-shareappmessage-bug/",
    "categories": "技术",
    "tags": "",
    "date": "2017-06-28 15:33:00 +0800",
    





    
    "snippet": "使用微信的JSSDK，可以在转发图文给朋友或者转发到朋友圈的时候，对转发的标题，描述以及图片进行自定义，这是个很好的功能，然而最近测试的时候发现一个Bug，当转发的链接是OAuth链接的时候，这段定义就失效了。问题描述先简单说一下什么是OAuth链接，参考微信的说明文档 https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp14...",
    "content": "使用微信的JSSDK，可以在转发图文给朋友或者转发到朋友圈的时候，对转发的标题，描述以及图片进行自定义，这是个很好的功能，然而最近测试的时候发现一个Bug，当转发的链接是OAuth链接的时候，这段定义就失效了。问题描述先简单说一下什么是OAuth链接，参考微信的说明文档 https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842微信OAuth的链接格式是这样的 https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 其中的 REDIRECT_URI 就是我们自己的网页链接，这段链接只能在微信里面访问，微信会得到通过用户授权得到用户的信息，然后跳转到 REDIRECT_URL 将用户信息传过来关于JSSDK的分享自定义，微信的说明文档在此处 https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115获取“分享给朋友”按钮点击状态及自定义分享内容接口wx.onMenuShareAppMessage({    title: '', // 分享标题    desc: '', // 分享描述    link: '', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致    imgUrl: '', // 分享图标    type: '', // 分享类型,music、video或link，不填默认为link    dataUrl: '', // 如果type是music或video，则要提供数据链接，默认为空    success: function () {         // 用户确认分享后执行的回调函数    },    cancel: function () {         // 用户取消分享后执行的回调函数    }});上面的代码中，注意link的描述，”该链接域名或路径必须与当前页面对应的公众号JS安全域名一致”，就是说你转发的链接必须与你公众号的JS安全域名一致，因为安全问题，这个设置无可厚非。 你不能自己的图文在 https://www.mydomain.com 而分享其他链接如 https://www.baidu.com， 当你这么设置的时候，这段分享自定义的脚本就全部失效。现在问题来了，如果我想使用微信自己的OAuth链接进行分享的话，也会失效，虽然是他自家的域名，微信同样认为这个链接和JS安全域名不一致，而如果直接分享 https://www.mydomain.com/xxx 的链接时，是无法从微信里得知用户信息的。JS安全域名是可以在公众号管理后台设置的，但是无法把open.weixin.qq.com或者qq.com设置为JS安全域名的。看起来似乎是无解了解决方法经过思考，归纳一下问题就是在于两点  JSSDK只能转发同域名下的链接 https://www.mydomain.com  必须使用 https://open.weixin.qq.com 开头的OAuth链接才能识别微信用户的身份解决方法其实很简单，把OAuth的链接编码，并且传给自己的代码，使用后台跳转如$oauth_url = \"https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect\";$encoded_url = base64_encode($oauth_url);$new_url = \"https://www.mydomain.com/jump?url=\"+encoded_url;此处 $new_url 代替之前的转发url，他的域名是符合JSSDK安全域名定义的Jump里的处理规则就是解码以及后台跳转，伪代码如下$encoded_url = request['url'];$url = base64_decode($encoded_url);header(\"location: \".$url);这个问题困扰了我好久，还好终于解决了2019-02-27 补充这个问题不是微信的bug，其实转发的时候可以直接转发自己域名下的地址，比如 https://www.mydomain.com/share/news/123 然后，在这个具体的页面里面，如果需要OAuth，进行二次跳转，而不是必须一开始就拼接OAuth的地址，这个问题是开始钻了牛角尖了。。。【全文完】"
  },
  
  {
    "title": "《软技能》读书笔记",
    "url": "/2017/06/reading-soft-skills/",
    "categories": "读书",
    "tags": "reading",
    "date": "2017-06-12 03:53:20 +0800",
    





    
    "snippet": "网上经常有程序员情商低的段子，从一个侧面也说明了程序员对代码的给予了很高的关注度，但是忽略了很多其他方面。《软技能》正是一本从另一个角度写给程序员的书，从本书的副标题“代码之外的生存指南”也可以看出，作者对程序员的容易忽视的软肋进行整理以及提出给出解决方案。本书涉及很多方面，分为职业篇、自我营销篇、学习篇、生产力篇、理财篇、健身篇、精神篇等七篇，我个人觉得前4篇值得更多关注，后面3篇可以参考...",
    "content": "网上经常有程序员情商低的段子，从一个侧面也说明了程序员对代码的给予了很高的关注度，但是忽略了很多其他方面。《软技能》正是一本从另一个角度写给程序员的书，从本书的副标题“代码之外的生存指南”也可以看出，作者对程序员的容易忽视的软肋进行整理以及提出给出解决方案。本书涉及很多方面，分为职业篇、自我营销篇、学习篇、生产力篇、理财篇、健身篇、精神篇等七篇，我个人觉得前4篇值得更多关注，后面3篇可以参考其他更多专门论述的书。职业篇  大多数软件开发人员从职业生涯一开始就犯了几个严重的错误。截至目前，最大的错误就是没有把自己的软件开发事业当作一桩生意来看待。不要被愚弄了，当你为了谋生一头扎进写代码的世界时，其实你和中世纪小镇上开铁匠铺的铁匠没什么差别。确实，时代或许已经改变了，我们中大多数人现在为公司工作，但是我们的技能和生意都还是自己的，我们随时都能换个地方另起炉灶。这种心态对于管理职业规划至关重要。因为只有你开始把自己当作一个企业去思考时，你才能开始做出良好的商业决策。但是，如果你已经习惯于领取一份固定的薪酬（注意，你的工资还真不是取决于你的表现），这会很容易导致你产生另一个心态——你只是在为某家公司打工。尽管在你的职业生涯的某个特定时间段里，你可能确实是在为某家公司打工，但是千万不要让那个特定的角色固化了你和你的整个职业生涯——这一点非常重要！这是一个思路转换的问题，是主动的心态或者是被动的心态，很多书籍会提到这一点，我相信认识到这一点的人行为方式会发生变化，越早认识到这一点对自己越有利。  想象一下这样的场景：你走进面试房间，与面试官握手致意。当他看你的时候，脸上露出了似曾相识的表情：“嘿，我认识你。我在你博客上看过你的照片。我读过你博客上的好多文章呢。”对普通人，面试官恰好读过你博客的概率太低，不过我们大可以将自己的博客地址放到简历上，有兴趣的面试官自然会在面试之前浏览你的博客，这样就会对你的关注点，文章水平，代码水品会有更进一步的了解。自我营销篇  在软件开发行业，营销的名声并不好。一般人提起营销人员都会皱眉头，因为很多营销人员会急功近利地使用不诚信的手段。似乎每天都有无良的营销人员为了一己私利而兜售新骗局。当前，营销的概念的确被某些人玩坏了，甚至成了一个贬义词。但其实这是一个正常的商业活动，开发人员不应有偏见，更不能以此拒绝正常的营销。  自我营销要从打造能代表你自己的个人品牌做起。你不可能将所有的东西全部呈现出来，因此，对于自己成为怎样的人、给世界呈现怎样的形象，你要谨慎决定。如果你也想在有人多次接触你或者你的产品时营造出一种亲切感，个人品牌能帮到你。  作为一名软件开发人员，可以用来推销自己的最佳媒介之一就是博客。再次提到博客的重要性，第21章 “创建大获成功的博客”，值得反复翻阅营销博客的几个方法：  要有自己的域名，免费博客的域名一般是二级的，搜索引擎给的权重是不一样的  持之以恒，保持规律输出，一般最好一周至少要有一篇  去知名博客类似主题发表自己的看法，并附上链接，不可发只有自己博客链接的垃圾评论  最重要的，要写有价值的内容，而不是堆砌大牛的博客  https://johnpapa.net/  https://blog.codinghorror.com/ Stack Overflow 创始人之一  https://www.hanselman.com/  https://www.smartpassiveincome.com/ “无处不在”策略  如果你能帮助足够多的人们得到他们想要的东西，你就会得到自己想要的东西。学习篇  第1步：了解全局，第2步：确定范围，第3步：定义目标，第4步：寻找资源，第5步：创建学习计划，第6步：筛选资源   这些步骤做一遍第7步：开始学习，浅尝辄止，第8步：动手操作，边玩边学，第9步：全面掌握，学以致用，第10步：乐为人师，融汇贯通十步学习法，也可以参考《如何阅读一本书》的主题阅读，有相通的概念生产力篇  一切始于专注专注的实践方法：番茄工作法定额工作法，规定每天完成多少个番茄后续3篇理财篇 可以参考《富爸爸穷爸爸》《小狗钱钱》等书籍健身篇 可以参考《当我谈跑步时，我谈些什么》精神篇 可参考哈佛《幸福课》公开课，《高效能人士的七个习惯》等后记这本书写的比较宽泛，章节很多很简洁，就像一篇一篇的博客，所以也适合平时遇到类似思考时拿出来参考。其中关于创建博客，学习方法，提升生产力等部分则有很强的操作性，可以直接拿来实践是否适合自己。【全文完】"
  },
  
  {
    "title": "常用前端类库整理",
    "url": "/2017/06/useful-frontend-library/",
    "categories": "技术",
    "tags": "javascript",
    "date": "2017-06-05 23:44:00 +0800",
    





    
    "snippet": "做前端开发免不了要使用一些静态公共库，如果代码部署在互联网上面，我们可以使用CDN，如：  新浪的CDN https://lib.sinaapp.com/  百度的CDN https://cdn.code.baidu.com/但是如果我们需要部署在内网，或者需要使用一些不太常见的类库，那么这个时候公共CDN也就不好办了这里提供一个思路，我们可以创建一个自己的静态公共库方便重复使用约定    ...",
    "content": "做前端开发免不了要使用一些静态公共库，如果代码部署在互联网上面，我们可以使用CDN，如：  新浪的CDN https://lib.sinaapp.com/  百度的CDN https://cdn.code.baidu.com/但是如果我们需要部署在内网，或者需要使用一些不太常见的类库，那么这个时候公共CDN也就不好办了这里提供一个思路，我们可以创建一个自己的静态公共库方便重复使用约定      以下假设文件部署到 https://www.caiyunlin.com/public 路径下        所有文件存放在public文件夹之下，这样在本地的话，类库的根路径就是 https://www.caiyunlin.com/public, 开发代码中对类库有引用则从路径 /public 开始引用即可        和公共CDN命名方式一样，类库以名称和版本分级目录存在，如：jQuery类库3.2.1版本使用下面链接, https://www.caiyunlin.com/public/jquery/3.2.1/jquery.min.js, 这样有多个版本时不会冲突        引用类库中可以包含相关的demo文件，这样可以方便参考和查错，如： https://www.caiyunlin.com/public/fullcalendar/3.2.0/demos/agenda-views.html        类库文件只会按规则增加，不会删除和修改，这样方便旧版正在运行的项目  几个优点  方便重用，同一个网站部署，只需要部署一次public文件夹，部署方式也仅仅是复制一下，各个子应用就可以直接使用，且子应用的文件夹只包含自己的内容  移植方便，当需要部署到不同的服务器，或者线上环境，只需要拷贝public文件夹，不需要的内容直接从public中删除即可  临时性的项目可以直接引用在线路径，不用部署public代码【全文完】"
  },
  
  {
    "title": "Windows 下好用的软件整理",
    "url": "/2017/06/useful-softwares/",
    "categories": "技术",
    "tags": "vim, editor, powershell",
    "date": "2017-06-05 22:50:00 +0800",
    





    
    "snippet": "工欲善其事必先利其器。给大家分享一下我常用的感觉比较好的软件。桌面截屏 - FSCapture桌面截屏 - FSCapture\t非常简单的截图小软件，可以添加水平印，也可以对图像进行简单处理。 可设置水印、撕边、阴影等效果！ 软件还附带放大镜，拾色器，屏幕标尺等小功能。 本站的截图基本是用它在处理的。 \t桌面动态截屏 - LICEcap桌面动态截屏 - LICEcap\tLICEcap 是一款...",
    "content": "工欲善其事必先利其器。给大家分享一下我常用的感觉比较好的软件。桌面截屏 - FSCapture桌面截屏 - FSCapture\t非常简单的截图小软件，可以添加水平印，也可以对图像进行简单处理。 可设置水印、撕边、阴影等效果！ 软件还附带放大镜，拾色器，屏幕标尺等小功能。 本站的截图基本是用它在处理的。 \t桌面动态截屏 - LICEcap桌面动态截屏 - LICEcap\tLICEcap 是一款短小精悍、免费开源的屏幕录像 GIF 动画制作软件，启动软件后，会显示一个中间透明的窗口框，LICEcap 可以将框框范围内的屏幕内容变化全部捕捉录制下来并保存成 GIF 格式的动画图片。  \t动态截屏+GIF编辑动态截屏+GIF编辑 - ScreenToGif    上面一款工具的增强版，除了截屏，还可以编辑GIF文件，增加字幕等     磁盘空间分析 - SpaceSniffer磁盘空间分析 - SpaceSniffer\t磁盘渐满却不知如何清理文件? SpaceSniffer是一个可以让您硬盘中文件和文件夹的分布情况的应用程序。 SpaceSniffer可以很直观的以区块，数字和颜色来显示硬盘上文件夹，文件大小，还能用筛选器过滤出要找的文件。 点击每个区块能进入该文件夹得到更详细的资料。 \t密码管理 - KeePass密码管理 - KeePass\t想保存自己众多的密码，但是又不太相信各大厂商？ KeePass 就是专门为了解决这个问题的，它是一款开源的密码管理软件，包含了一个强大的密码产生引擎与加密储存机能，能够提供一个安全的密码储存空间。它所有的数据都是保存在你本地的密码文件里，你也可以用云盘去同步它，但是没有主密码没有人能打开它。 保存好密码，就可以按快捷键Ctrl+Alt+A自动填充网页上的密码输入框，高效又安全。 \t远程桌面管理 - MultiDesk远程桌面管理 - MultiDesk\tMultiDesk 是一款小巧的远程桌面连接工具（只有一个执行文件，绿色免安装），可以完美替代MSTSC。 \t热键管理 - AutoHotKey热键管理 - AutoHotKey\tAutoHotkey 是一个可以让你定义自己的热键、热字串或设定的条件自动执行重复性工作，说一下我使用的两个场景，1是我经常随手会记录一个日志，所以我定义了按 Ctrl+T，就会自动在当前光标处插入当前时间，如2020-04-06 16:11， 非常方便。    2是我经常写markdown文件的时候，需要截图，我就定义了一个热键，比如Ctrl+U，这样我先截图复制图片内容，然后通过这个热键，就会自动调用一个脚本，将内存中的图片保存并且上传到七牛云的空间，然后返回图片URL，再自动粘贴到文档中，非常方便，下面是示例效果。 \t其他软件整理为方便管理，软件统一成固定的格式的压缩包softwarename-1.0.zip，如flashfxp-3.6.0.zip，就是FlashFxp的3.6.0版本下载地址为 ： https://public.caiyunlin.com/flashfxp-3.6.0.zip自动安装自动安装使用PowerShell命令行的方式，只需要使用两行代码即可安装需要的软件iex (new-object net.webclient).downloadstring('https://www.caiyunlin.com/dev/powertask')install FlashFxp 具体使用说明  打开PowerShell命令行  复制 iex (new-object net.webclient).downloadstring(‘https://www.caiyunlin.com/dev/powertask’) 到PowerShell命令行执行  如果遇到错误，可能是执行脚本权限问题，可以先执行 Set-ExecutionPolicy bypass再执行上一步  切换到需要安装的目录，如c:\\softwares，执行需要安装的软件 如： install FlashFxp  也可以直接指定安装目录 如：install FlashFxp c:\\softwares\\FlashFxp  注意：软件的安装只是简单的解压缩，如果是绿色软件，可以直接使用，如果是需要进一步安装的，需要打开目录，执行安装文件  注意：下载的zip文件在安装后会自动删除，如需要可自行压缩，或者使用 get xxx 直接下载一份，如 get flashfxp目前可以支持的软件，会在使用过程中慢慢更行此列表，直接执行 install 可以显示可用的软件清单install FlashFxpinstall 7Zipinstall Gitinstall MongoDBinstall MultiDeskinstall NCFtpinstall phpinstall Puttyinstall SublimeTextinstall Svn实现思路  申请一个存放软件的空间，我使用的是七牛云，免费的可以支持10G  整理软件包资源，上传到空间里  使用PowerShell实现下载文件Get-WebFile，解压缩Expand-Zip等功能，并且提交到github上，获得可在线访问的地址  封装PowerShell脚本到Module，使用动态加载脚本的方式载入在线脚本，具体实现可参考 https://github.com/cylin2000/powertask  执行脚本下载和安装软件这件事情没有用到太复杂的技术，但是可以省下不少时间。【全文完】"
  },
  
  {
    "title": "《要事第一》 读书笔记",
    "url": "/2017/02/reading-put-first-things-first/",
    "categories": "读书",
    "tags": "reading",
    "date": "2017-02-08 19:20:20 +0800",
    





    
    "snippet": "这本书是《高效能人士的七个习惯》中第三个习惯“要事第一”的详解，是一种新式的时间管理方法。 如果你对时间管理有困惑，尝试了数种时间管理方法和时间管理软件，依然不奏效，建议读一读此书。现状我相信很多寻求时间管理方案的人，可能是因为下面的痛楚：  事情太多，太杂，每天都忙不完，最后却又不知道忙了些什么  不怎么忙，但自己有很多想做的事情却迟迟开始不了，拖延症严重这两个痛楚，我是都经历过的，因为从...",
    "content": "这本书是《高效能人士的七个习惯》中第三个习惯“要事第一”的详解，是一种新式的时间管理方法。 如果你对时间管理有困惑，尝试了数种时间管理方法和时间管理软件，依然不奏效，建议读一读此书。现状我相信很多寻求时间管理方案的人，可能是因为下面的痛楚：  事情太多，太杂，每天都忙不完，最后却又不知道忙了些什么  不怎么忙，但自己有很多想做的事情却迟迟开始不了，拖延症严重这两个痛楚，我是都经历过的，因为从事的是软件开发工作，在项目紧急赶上线时间的时候，我经常被第一个痛楚困扰，当排查出很多低级错误的时候，更是狠下决心有时间一定要好好读一下软件相关的经典书籍，防止再踩坑。 然而项目上线后，休息几天就会进入了第二个痛楚，当初的痛点不那么痛了，开始懒散，拖延，待办事项里不能打钩的顽固任务，成了打击自己的工具，进而更加自责。比如，《代码大全》 是我一直想读的一本书，豆瓣评分9.3，想来是一本好书，作为以软件开发人员，应该读一读，但我至今第一章都没有读完。我在反思，为什么这本《代码大全》我一直读不下去？   要事第一，这四个字不难理解，对于软件开发者来说，读这本讲软件构建和实战技巧的书无疑是一本重要的事，我知道这个道理，为什么还是没能读下去？我读了时间管理的书《搞定I》，《番茄工作法图解》，《吃掉那只青蛙》等，使用了Todolist,Wunderlist,谷歌日历还有GTD相关软件，安排自己的待办事项，然而还是不怎么奏效。时钟和罗盘本书第一部分点出了区别：  时钟代表我们的许诺、约会、进度表、目标、行为——即花费时间所做的事情以及如何来管理时间。 罗盘代表我们的构想、价值观、原则、使命、良知、方向——我们认为重要的事情以及如何生活。这是个很好的比喻，时钟表示怎么去做，罗盘表示为什么去做。我突然发现，我之前寻找的方案都集中在时间的层面，却没有好好想过为什么要去做，比如《代码大全》，我为什么去要去读？  因为我从事软件行业？  因为很多人都推荐，很多大牛都读过？  因为我定了计划，一年要读多少书？  因为我要跟别人吹嘘，我读过这本大部头？  这些理由都不足以支撑我来干这个事情，而且还会想  这个通用的书对我现在的项目，帮助有多大？  读完没有应用最终会忘掉，那还读了干嘛？  由此种种，最终导致我迟迟没有开始去做这个事情罗盘是指引方向的，我们可以不知道这个比喻，但是我们的潜意识，在骨子里不想做的事情，是没有意愿没有动力去做的。  之所以我们把这些事情还列在自己的待办清单里，只是因为我们拿着别人的罗盘，却以为是自己的罗盘了。我知道了，当务之急，是找到自己的罗盘三代时间管理方法作者调查了一百多部书籍、数百篇文章以及各种各样的日历、计划手册、软件和其他的时间管理工具，发现大多数人更认同所谓的三“代”时间管理方法。  第一代建立在“备忘录”的基础上。它“顺应潮流”，但又记录下你想做的事情——写报告、开会、修汽车、清理车库。这一代是以便笺和核对表为特征的。如果你属于这代，你会随身携带核对表，作为参考，以免忘事。希望一天下来，完成了打算做的很多事情，可以从表中将它们划掉。如果有未完成的任务，就将它们放在明天的表中。  第二代是“计划与准备”，以日历和约会登记簿为特征。这一代强调效率、个人责任感、确立目标，事先做计划，列出未来的活动和事情时间表。如果你属于这一代，你会安排约会、写下承诺、确定最后期限、记下开会地点。你还可能用电脑或网络等来做记录。  第三代的方法是“计划，排序，控制”。如果你属于这一代，你可能要花些时间明确自己的价值观和优先考虑的重点。你会问自己：“我想要什么？”为了实现这些价值观，你制订了长期、中期和短期目标，将自己每一天的活动都进行优先排序。这一代的特征是有各种各样的计划手册和时间管理手册——电子的或写在纸上的——对每天的计划都有详细列表。我整理了一下，相关的软件可以体现在：  第一代：各种便签，Clear，提醒事项,Wunderlist  第二代：Google日历，Outlook  第三代：各种GTD软件，如：Omni Focus，Doit.im，滴答清单现在我更加确定，之前花费了太多时间在前3代时间管理方法上，但是对于自己真正想要的却不是很清楚，所有总觉的有点不得章法。三代时间管理方法的优缺点如下：第四代时间管理方法：以角色为基础安排每周日程要解决这些问题，作者提出了第四代时间管理方法：以角色为基础安排每周日程 全书的第二部分，都是在论述这种方法的优点，操作方法以及遇到阻力是应该怎么办这里贴一张示例图，有个直观的概念简单说下我能看到的优点：  角色法安排任务，防止失去生活的平衡，大家都不愿看到事业有成，但家庭支离破碎的结果。这个方法同样可以用作月度计划和年计划的参考。  一周计划，一周包含五天工作和两天休息，恰好是包含工作和生活的最小单元，以周安排事务，有全局观去平衡工作和家庭，也会减少以日为单位安排，但是没完成任务后去熬夜或者去沮丧的缺点。  每日调整，将之前的每日计划，改成每日根据需要去调整，能够很好的应变突发变化  不断更新，从身体，智力，精神，社会/感情 4个方面，根据评测表，让你每周可以回顾自己，找到自己真正的需要，并安排下周计划我相信大家最终的目标应该都包含幸福的生活，按此方法，你会不断的提醒自己，更新自己：  你不会讨厌情人节，圣诞节，春节，生日，因为那是你作为配偶，儿子女儿，父母这类角色往对方的情感账号里存钱的好时机  你不会再安排诸如，每日早起，每日跑步，每日写作这样容易失败的计划  你不会再有安排了计划，却被突然打乱而满是恼怒，继而得罪别人或者放弃整盘计划的冲动  你不会再有一步一步执行完成计划，终了却发现这不是我想要的那种迷茫我参考图片制作了一个Excel，可以接作为电子版或者打印到A4纸上使用。点此下载后记本书的第三章：相互依赖的协作增效，和第四章：以原则为中心的力量与平和，建议参考《高效能人士的七个习惯》或者其他项目管理的相关书籍，对我来说，这本书提供“要事第一”的实际操作方法比较重要，其他的论述略简单不够全面。整体上，要做好“要事第一”，更重要的仍然是“个人宣言”部分，所以对《高效能人士的七个习惯》领悟的比较透彻的人可以略读或者不读此书，毕竟方法不是最重要的，最重要的还是思想，也就是本篇标题所讲的，找到你自己的罗盘，即“个人宣言”。最后，我也不能保证这第四代时间管理方法就是非常有效的，但是我决定花一定的时间去尝试和总结！【全文完】"
  },
  
  {
    "title": "如何制作可实现的年度计划",
    "url": "/2017/01/how-to-set-yearly-plan/",
    "categories": "随笔",
    "tags": "reading",
    "date": "2017-01-01 13:31:00 +0800",
    





    
    "snippet": "这是一篇听课笔记，是我听喜马拉雅《小强升职记：带你六步制作可实现的年度计划》的总结。关于年度计划，网上有句经典语录叫： 我2015年的目标就是搞定2014年那些原定于2013年完成的安排，不为别的，只为兑现我2012年时要完成的2011年年度计划的诺言你是不是也是这样呢？那你想知道什么原因吗？第一课：年度计划总实现不了的原因是什么小强的经验总结，年度计划实现不了的原因有4个，假大空全  假：...",
    "content": "这是一篇听课笔记，是我听喜马拉雅《小强升职记：带你六步制作可实现的年度计划》的总结。关于年度计划，网上有句经典语录叫： 我2015年的目标就是搞定2014年那些原定于2013年完成的安排，不为别的，只为兑现我2012年时要完成的2011年年度计划的诺言你是不是也是这样呢？那你想知道什么原因吗？第一课：年度计划总实现不了的原因是什么小强的经验总结，年度计划实现不了的原因有4个，假大空全  假：目标不是发自内心的比如说，有朋友见到你说，你最近脸变圆了，你很郁闷，所以你写下一个目标，新的一年，我要减重10斤。 这个目标好假，因为你根本没有因为那点体重而痛苦，也没有想让自己变成超模身材的热情。你真正的心态是，我虽然想让自己瘦一点，但另外一方面又没觉得有什么大不了，所以瘦身只是一时激情的假目标。  大：目标超出了能力范围比如说，你想每天走一万步，看上去挺简单，怎么超出能力范围了呢？请注意，超出能力范围的不是走一万步，而是每天  空：写下了目标，但是没有落地到每个月，每一天的计划当中比如说，你一年打算读50本书，往往前两个月，很积极，每个月都能读4,5本书，到中间就抛之脑后了，年底的时候突然想起来，突击完成任务，效果可想而知  全：想把所有写下的目标全部实现至刚则易脆，万一有一个没实现，就会失去对整个年度计划的信念。所以有的时候，我们不是没有能力完成计划，而是因为追求完美而没法完成。如果你做过上一年的年度计划，建议你用假大空全的方法，标注出不靠谱的年度目标，看看是不是没有实现附：小强2016年的年度计划的完成情况  全家日本自由行8天  橙子学院合作时间管理课程，卖了2000多份  读了60本书，写60篇读书，完成比完美重要  一个人的英雄之旅，去了新疆  每周打篮球两次  学习了EBO式行动学习技术，提问为主  （未完成）做一本送给格格（小强女儿）的绘本，2016年写了13个故事，但是都不满意，且发现做绘本没有那么容易  （未完成）运行墨立方成长俱乐部，2010年成立的，周期性找嘉宾做分享（西安太多类似组织，所以停止了运营）什么样的年度计划是好的年度计划呢？  首先是可实现的  然后是你不会因为太多年度计划而感到焦虑，也不会因为年度计划没有全部完成而感到自责如何制作一份自己的年度计划呢？参考制作年度计划的全景图第二课：如何写出“走心”的年度计划一般你是怎么做年度计划的呢？是不是年底或者年初，找个空闲时间，往桌子前一做，拿一张纸，拿一支笔然后就拖着腮帮子在那想,我今年都要做些什么呢？噢对这个然后写下，还有那个，写下，然后分解，每个月做什么，每周做什么，每天做什么在拆解的过程中你会感觉非常爽，感觉这个目标已经实现了一样。如果你是这样做的可能遇到两个问题  目标经常变  年度目标写的去丽江发呆，3月份可能就改成了去日本看樱花，说明写的时候并没认真  年度除写了10个目标，慢慢变成15个了，慢慢这样下去，你就不会把年度目标当回事了，变成了一种可有可无的东西  3分钟热度  比如说，每天用扇贝英语背单词50个，很明确具体可执行，但是坚持了15天，你就开始忘记背了，最后无疾而终了为什么遇到这样的问题，因为你制定目标的时候，走脑而没有走心你可能会问，走脑的目标是怎样，走心的目标又是怎样？举个例子，瘦身10斤这个目标，走脑还是走心呢？这个目标不能从字面判断是走脑还是走心的，而是看这个目标是从哪来的  有些人的瘦身目标是从需要来的，比如说体重有点太重了，别人说我有点太胖了，心里觉得挺膈应，需要瘦身，但其实你的内心觉得胖点也无所谓  另外一些人的瘦身目标是从不得不要来的，比如说突然发现好多衣服穿不上，早晨出来一照镜子，觉得不好，但是你也可能会觉得重新买个衣服呗，反正旧的不去新的不来。总之就是因为需要去瘦身，因为不得不要去瘦身，但就不是因为想要而去瘦身小强参加了5期瘦身营，发现凡事瘦身成功的人，要不然是因为痛苦，要不然是因为热情。  痛苦就是：感觉到胸闷，气短，身体感觉到要发出警报了  热情就是：我太太太太喜欢瘦的样子，完全不能接受生了小孩胖的样子，我一定要瘦回去走脑的目标就是需要，不得不要，走心的目标就是自己真正想要去做对于走脑的年度计划一开始就注定失败了，只不过用12个月去证明，走心的目标就会有两种动力在支持着，一种就是热情一种就是痛苦，不然别人怎么说都会坚持下去，即使遇到的平台期其实很多人的计划都是在平台期放弃的，当你在平台期的时候，有了这两种动力，你就会坚持下来，真正的达到自己的目标怎么才能制作一份走心的年度计划呢？从展望愿景开始为什么要这么做，有两个原因      从愿景出发是人类最自然的方式，只不过很多人没有觉察到比如说，中午同事们打算聚餐去，那这时脑袋里浮现的是什么呢？不是去肯德基还是川菜馆，而想象起聚餐的那种场景，大家热热闹闹的场面，这个就是一个愿景，然后才会去选择，去哪里吃饭，这时候才会根据愿景去判断去哪一家。再举个例子，你计划去美国旅行，脑袋里浮现的不是路线，去哪里住，怎么卖票等，脑袋里浮现的是：我在66号公路自驾时阳光洒面路面的场面，可旁边开过去的漂亮MM打招呼，吹口哨。如果你喜欢篮球的话，浮现的可能是，我在勇士队的季后赛主场，用我全身的力气去呐喊加油，虽然人家听不懂        不仅仅让你吸引到资源和人脉，还会让你变得更加积极有点像 吸引力法则，比如晚上会小区的时候，全家人都在车里喊，有车位有车位（这不是一个目标，这是个愿景），但可能经常回去一辆车从小区开出来，空出一个车位。 感觉好灵，其实是吸引力法则重新从积极的方面去解释了这个巧合。  愿景也是一样，当发生一些符合你愿景的事，你会说，哎呀这正是我想要的，这也是从积极的方面去解释了这个巧合怎么去展望愿景呢？方法是写一封给5年后自己的信，当这封信写完的时候，5年后自己的样子就历历在目了小强示范的给5年后自己的信  前不久刚和家人从非洲回来，总算是和家人一起足迹遍布7大洲了，我终于可以嘚瑟的说，我不仅是个中国人，还是一个地球人现在财务基本自由,因为几本书还有书的延伸品包括在线课程和实体产品都销售的不错苹果出的新手机新电脑什么的坐为脑残粉可以毫不犹豫的拿下了应该更多的关心自己的身体和梦想了吧我每周都回去健身房两次，除此之外还经常打羽毛球和篮球，我的杀手锏已经不再是充沛的体力和积极的跑位的，中距离远投也有很高的命中率写下的100个梦想，也基本完成了一半，争取把剩下的尽快搞定除此之外，我还经常和一大群志趣相投的朋友一起读书喝酒吃肉，互相支持着，这种感觉真是太棒了这就是我想要的生活，简单，幸福，加油吧~~这封信可以一直保持着，每年可以做些稍稍的修改，可以放在笔记的快捷方式里，没事就打开看看，它就像是一个能量球一样，当我累的快不行的时候就读一遍，补充点能量。写这封信看上去简单，也很容易进入两个误区第一个误区：列干条条，没有画面感  每周去健身房两次，10月份去台湾旅行，制作时间管理在线课程要运用5感去写，看到什么，听到什么，问到什么，尝到什么，感觉到什么举例：肯德基的广告  54层酥皮的全新肯德基法风烧饼，法式工艺，层层酥脆，口口汁香，搭配熏鸡肉和生菜，美味层层叠，一早过足瘾画面中的男主角还要要上一口，汁液四溅，然后还要做出很享受的样子，这就是刺激5感的愿景式广告第二个误区：写的全是感受，就想是倾述一样，但没有什么用  嗨，五年后的我，你一定过得非常幸福吧，一定是有人爱有事做，也有所期待吧，每一天都过得非常充实，虽然外面的世界在不停的改变，但是我们永远也跟不上它的步伐所以我们不要在意别人是怎么样想的，怎么活的，我只需要做好自己就行你在写愿景的时候，写这封信的时候，你可能某个地方忍不住笑出声来，或者眼泪流下来，或者有某种怦然心动的感觉，这就对了，就特别走心了。现在你先不要评判你写的东西能否做得到，先把他写下来，因为你一评判的时候，你就开始走脑了，就不是走心了，后面有步骤判断这个愿景是不是靠谱。下面你可以开始写一封给5年后自己的信了，开始之前，你要准备3件事：  准备一个环境，时间，最好选一个周末的早晨，早起半小时，家人都没有起床，这时候写容易和自己链接  准备一杯水，不要因为写的时候喝水什么的打断思路  准备笔和纸，强烈建议笔和纸，因为笔纸更容易把脑袋的东西写下来，兴致来了还可以画幅画。如果你要用电子笔记存档，可以写完了拍个照也可以使用一个柔和背景音乐，让自己容易思绪流淌出来。开始可以这么写，5年后的邹小强你好，你现在过着一个怎么样的生活呢？。。。。。第三课：从幸福的八个方面入手上一课我们写好了愿景，这一讲将愿景进行分类一下，为什么要进行分类呢？我们可以想象一下  事业狂每天起得比鸡早，睡的比狗晚，吃的比猪差，就一门心思的干事业，结果老婆跟隔壁老王跑了，忙到最后离婚了，家庭破碎了，那还忙个什么呢。开始时打拼，后来就是心灵寄托了  低品质勤奋者比如说听完逻辑思维后，一时心血来潮下单买了很多书，但却从~来~不~看~，有人只要推荐课，再贵也要去上，每周都参加各种沙龙活动，跟不同的人碰撞交流，回家之后才发现好几天没有打扫卫生了，家里一地的灰  拜金女比如说那位宁愿在宝马里苦，也不愿在自行车上笑的那位，凡事先算算能赚多少钱，在看看做不做这个事  柔弱男风一吹就倒的宅男，整天在家待着，网下唯唯诺诺，网上敢笑红尘，名副其实的键盘侠  空想家小强的同事，国企，整天说我在也不想在这呆了，好无聊好郁闷，要出去开个面馆，创业，结果小强出来5年了，他还在国企里面待着上面这些人共同的特点就是生活失去的平衡，在某一方面投入了太多的精力和时间  事业狂，在事业上  低品质勤奋者，在个人成长  拜金女，在财务上  柔弱男，在健康  空想家，在梦想在单独一个方面投入太多精力，生活就失去了平衡。 想想我们为什么要做年度计划呢？是为了把自己真正想做的事情搞定，把时间花在自己真正想做的事情上是为了那种幸福感，但什么是幸福呢？罗素先生说：  参差多态，乃幸福本源所以年度计划应该是更多元，更有趣，包含人生多个方面的一种平衡。如果你也认同这个理念，可以继续参考下面一个九宫格可以把九宫格想象成一个人，脚下踩着的是基础，一个人的基础要身体健康，得有钱，得朋友有关系，人是一个群体动物中间就是工作和生活的平衡，头顶是3种是精神上的享受中间的格子：可以写自己的名字，或者写年度主题，比如2017年：打拼的一年，或者积累的一年，是你的年度语你也可以把你的笔记资料按照这些方面分类接下来把写给5年后的自己愿景放到九宫格里面归类，归类不要纠结于对错，这个只是对自己的一个初心的一个投射，没有对错之分。注意不要把格子填满，下面留些空白，下一讲把这些愿景分解的目标，写在下面。你也可以更进一步可以制作成图片，放在自己电脑或者手机的桌面，没事可以看看，虽然这个有点类似成功学的梦想板的那一套，但确实有事很有效果（小强在写《小强升职记》这本书的时候，就经常这么做，有一种偷偷的暗暗努力的感觉，觉得很棒）第四课：把美好的愿景转化为明确的目标这一课把5年的愿景转化成这一年具体的目标，在转化的过程中，你可以能发现有些目标不是那么靠谱了，这并不是自己想要的，那这个时候就要勇敢的拿起大刀把它砍掉，这可以节省我们很多时间。问自己的一个问题，为了实现这个愿景，我要在接下来的一年，达到什么目标，然后把目标写在格子里，愿景的下面，这样就完成了愿景到目标的转换。有些愿景转化为目标，可能是简单的，如：  愿景是足迹遍布7大洲，接下来的目标可以是，10月份带家人去澳大利亚玩  愿景是保持着阅读的习惯，目标是一年阅读50本书也有些愿景比较难转化为目标，如：  心灵更加自由  我想财富自由  我要成为一个斜杠青年对于较难转化的，有一个简单的方法，三步，先定义，再计划，最后下一步行动  定义：什么叫心灵自由，去做没有做过的事  计划：请朋友列出想做的事      下一步行动：从朋友列出的想做的事，找出12个，每个月做一个    定义：财务自由，非工资收入大于总支出  计划：快速赚第一桶金，靠第一桶金投资获得被动收入（如希望每月有两万被动收入，那就需要240万，10%年收益投资）      下一步行动：接下来一年制作一个在线课，获得第一桶金收益    定义：斜杠青年，能够拥有多重职业（带来收入）和身份(IT男，瑜伽教练，工具书作家)的多元生活  计划：精深学习瑜伽  下一步行动：咨询了解知名瑜伽学习机构，报名学习课程第五课：用SMART原则让目标更容易实现如何保证目标能实现，没有人能保证，但是用SMART原则，可以增加实现几率  S:具体的  M:可衡量的  A:可达到的  R:相关的  T:明确的时间底线的关于相关性，比如 背单词这个目标，因为要通过教师资格证的考试，这样背单词目标和考教师资格证相关，那样就会更加有动力，如果光光背单词，没有其他相关，就没有意义。举几个目标的例子  我要三个月内学会谈吉他：不符合，不具体（什么叫学会？），换成在朋友聚会弹唱《春天里》靠谱一点  我想继续考研究生：不符合，（相关性，为什么考研究生？）如果是为了升职加薪，那么换成继续考研究生，增加升职加薪的几率，就比较好了  我要减肥：严重不符合（不具体，不可衡量，没有时间底线）换成三个月内通过每天跑三公里的方式减重10斤  我要找男朋友：不符合（结果不可衡量）换成每个月跟朋友聚会一次更好小强的感悟：做事靠系统，做人靠真心注意事项：  如果哪个格子没有目标，试着找一个，保持平衡  每个格子目标不要太多，不要超过3个，精力有限(太多的话，计算热情，痛苦，时机的方法取舍，适合各种选择困难症)            计划      痛苦      热情      时机                  学厨艺      8      8      4              弹吉他      2      2      5        找到帮助你实现目标的Key Man，Key Man就是掌握着实现计划的关键资源或关键技能          小强又一次去听一个很有名的人来西安做的演讲，然后他特别想听，有一个特别想问一个问题。但是现场有两百多人，嘉宾到提问环节，小强举了N次手都没用，终于发现这个嘉宾，要不然选择30岁以下的女性，要不然选择30岁以上的女性:)，感觉完全没戏了。 这时怎么办呢，有人说，可以冲上去直接问，或者抢过话筒问，或者让一个美女帮你去问，不过这些方式都不够优雅后来小强猫着腰走到会场另外一头，问拿话筒的服务员，说我下面想问一个问题，你能把话筒先给我吗？服务员就把话筒给他了，当前面的人回答问题之后，就可以直接问问题了这里的Key Man就是那个服务员      如果你做年度计划的时候，发现某个有助于实现目标的Key Man，把他写在目标旁边第六课：如何培养搞一个好习惯上面一课我们做好了带有目标的九宫格，现在请拿起就宫格，看你写着的2017年的目标，你会发现目标虽然很多，但只分为两类，一类叫习惯，一类叫项目  习惯就是周期性做的事情  项目就是多人多步骤完成的事情现在将九宫格的目标进行分类，习惯就在前面画个圆圈，项目就画个三角。现在看看你是怎么去培养习惯的呢？就拿培养跑步的习惯来说，是不是浏览超多的培养习惯的文章，然后买一堆装备，比如跑鞋，瑜伽垫什么的，在下载个APP，再加入一个群，一群人热热闹闹的在一起，当然还有可能在手机上设置一个循环闹钟提醒。你以为这样就算培养习惯了，其实这只能算作为热身，你有没有发现这些都是在你可控范围内去做的事，比如想买东西，花钱就能买到了，但是不可控的部分，你总是在逃避比如说，如何去制定培养习惯的计划，你会遇到什么阻碍，遇到阻碍的时候，你该如何调整呢，是不是这些压根没有想过，所以培养习惯没有那么容易成功了培养习惯是改变自己的一个过程，向内求才是改变的开始，跟自己链接，跟自己承诺，跟自己计划。培养习惯的方式有三步  建立一个仪式 写一个培养习惯的卡片,当做对自己的一个承诺  制定一个循序渐进的计划 先从两周开始，给计划增加3条命(注：3次没有做的机会)  积极的记录培养习惯中遇到的坑：  1次培养多个习惯 (每天6:30起床，背单词 是两个习惯) 换成（每天6:30起床，看美剧）  关注过程和感受，而不是结果  加入社群，但是潜水不说话，Lonely Together第七课：制作项目计划的“水滴计划法”上一课讲了习惯类的目标，这一课和大家分享，项目类的目标，如何做计划举例：制作时间管理的课程很多人遇到这个项目会怎么开始做计划呢，他会问自己一个经典的问题，下一步我该怎么办呢？然后列出步骤，比如说，第一步 列出课程大纲，第二步 完成第一节课的内容，第三步 完成第二节课的内容，等等，最后一步合成导出，放到网上，这算是把一个项目分解成一个个的行动了。这样的方式，虽然一个步骤一个步骤都很明确，但却比较容易深入细节，失去对全局的掌控，所以很多项目管理的新手，都有顾此失彼，突发状况不断的情况出现。这是因为他把项目和任务混为一谈了，项目和任务的区别如下：  项目：多人多步骤做的事 （面）  任务：一个人多步骤做的事 （线）小强制作项目计划的方法，叫水滴计划法，想象一下，一滴水滴入湖面，会发生什么反应呢？是不是 扑通一声，激起水花，泛起一圈一圈的涟漪，最后又归于平静做项目规划的时候，也是一样现在做的大部分事情，其实有人已经做好了框架，我们应该借助这些框架，比如说  竞品分析，用SWOT框架(Superiority Weakness Opportunity Threats)  生产作业现场发现了问题，可以用 人机料法环 框架，找出问题所在  创业项目，商业模式新生代的方法，客户是谁？价值主张是什么？核心业务是什么？渠道通路是什么？  给朋友买礼物不知道买什么时，可以使用衣食住行框架那你平常工作的时候，肯定会遇到这样的困惑，为什么同样是工作5年，同事小A就变成了经验丰富的骨干，而同事小C却还是菜鸟一枚呢？因为小C的工作经验就像是流水一样，匆匆流过，根本就没有存储起来，比如说你没做一个项目，都问自己，下一步该怎么办呢？下一步怎么办？好像每一步都很具体，执行起来也很顺利，但是你的经验并没有积累下来。而小A为积累经验，修建了一座水池，工作经验都在这座水池里存储起来，这座水池就是上面提到的框架，你想想每一次都用同样的框架，去做项目的分解，获得的经验有去不断的升级这个框架，自然就会成长的越来越快，这种框架里就是经验的一种体现水滴计划法可以当做思维导图的一种在项目计划方面的应用如果你有多个项目，有多个人在负责，应该如何掌控呢，建议使用甘特图第八课：用“4D工作法”管理好每天的事情年度计划完成不了的人，通常会有这样的想法，我把每天的事情忙完之后，再去做那些年度计划相关的事吧。 可以往往每天的事根本忙不完，就算忙完了也累趴了，哪有时间去做年度计划相关的事。所以一拖再拖，到底年底就开始感慨，时光飞逝，年度计划又落空了。不建议将当天的事和年度计划相关的事区别对待，他们应该混在一起，统统的列在每日的计划里面。那么问题来了，每天那么多的事，怎么去做每日计划，才会忙而不乱呢？那你现在是怎么管理这些事的呢？  有些人使用脑子记，这些人会经常遇到这样的场景，哎呀我把这事给忘了，我现在就帮你做。 这就是因为我们把事情记在脑子里，而我们的脑袋是擅长思考，而不是记忆，所以超过7件左右的事情，我们的大脑特别容易产生遗忘。除此之外，事情都记在脑袋里，你还会感觉到压力和焦虑，比如说，你在做PPT的时候，突然会想到，我还要做啥事的，怕他给忘了，你老这样想的时候，你会觉得压力真的很大  另外一些人把要做的事，一条一条写在清单上，这是一个特别好的习惯，但是这样列干条条的方式有两个不组          容易加班 有没有发现一天结束的时候，往往清单上简单的是都做完了，但重要的事都没有做，只能加班了      容易乐观估计时间资源 我们总是容易乐观估计一天内能完成的事，而又国语悲观估计了一年内能完成的事      4D工作法  首先准备一个本子（参考IM手账）用星标标出今天要做的重要的事，有限完成，左边的时间轴，合理评估一下今天的时间资源，合理安排计划，右边的空白区，作为自由区          建立一个启动每日计划的仪式 可以是早饭后，用一个待办工具，比如是滴答清单，列当天的待办事项。注意与其写固定时间，不如写场景，比如：开会后，下班回家地铁上，睡觉前      用4D工作法梳理脑袋里所有的事情 别人要你帮忙做事的事情，先经过自己的清单系统，看这件事情是不是最重要紧急的事，是就做，如果不是，就拒绝或者延期处理      把4D工作法梳理的事情写在本子上，立即去做的事情，就写在右边的自由区，标注星标      4D工作法在笔纸上的应用【全文完】"
  },
  
  {
    "title": "如何创建标准的 PowerShell 函数",
    "url": "/2016/12/how-to-create-ps-function/",
    "categories": "技术",
    "tags": "powershell",
    "date": "2016-12-02 14:46:00 +0800",
    





    
    "snippet": "PowerShell有很多内置的命令，我们自己也会创建很多自定义的脚本，上一篇介绍了我创建的一个在线PowerTask类库就是自定义的脚本，其显示的方式跟默认的命令很类似，如何使自己创建的脚本能有系统自带的命令一样的体验呢？答案就在于Function，在Windows PowerShell 2.0 中引入了一种新类型的Function，叫Advanced Function，通过它你可以创建出...",
    "content": "PowerShell有很多内置的命令，我们自己也会创建很多自定义的脚本，上一篇介绍了我创建的一个在线PowerTask类库就是自定义的脚本，其显示的方式跟默认的命令很类似，如何使自己创建的脚本能有系统自带的命令一样的体验呢？答案就在于Function，在Windows PowerShell 2.0 中引入了一种新类型的Function，叫Advanced Function，通过它你可以创建出跟Windows PowerShell的cmdlet体验完全一样命令。本文从以下几个方面讨论如何创建自己的 Advanced Function。命名一个 Function我们自己创建一个脚本，命名可能比较随意，比如 DownloadFile.ps1，用于下载一个文件，但是我们观察PowerShell自带的命令，一般是以 动词-名字 来组织命令的。 所以对于刚才的DownloadFile.ps1我们可以命名为 Download-File.ps1我们最开始创建的脚本可能是这样的  创建 C:\\Download-File.ps1 内容如下param(        [Parameter(Mandatory=$True)][String] $Url,        [Parameter(Mandatory=$True)][String] $LocalFile )$client = New-Object System.Net.WebClient$client.DownloadFile($Url, $LocalFile)这样一个基本的下载文件的Function就创建好了，测试一下，效果应该如下PS C:\\&gt; .\\Download-File.ps1 \"https://ss.bdimg.com/static/superman/img/logo/bd_logo1_31bdc765.png\" c:\\logo.pngPS C:\\&gt; ls c:\\logo.png    Directory: C:\\Mode                LastWriteTime     Length Name----                -------------     ------ -----a---         2016/12/8     14:52       3706 logo.pngPS C:\\&gt;内置帮助信息当我们不知道一个PowerShell命令如何使用的时候，我们一般会输入 Get-Help Cmdlet 的方式来获取信息，那么我们如何为Download-File提供帮助信息呢？我们可以使用内置的注释模块如下：&lt;#.SYNOPSIS    Download a file.DESCRIPTION    Download a file from internet, you must provided a valid url of the file.EXAMPLE     Download-File \"https://ss.bdimg.com/static/superman/img/logo/bd_logo1_31bdc765.png\" c:\\logo.png.EXAMPLE     Download-File -Url \"https://ss.bdimg.com/static/superman/img/logo/bd_logo1_31bdc765.png\" -LocalFile c:\\logo.png.PARAMETER Url    The Url information for the file to download.PARAMETER LocalFile    The destination file will dave in local#&gt;param(        [Parameter(Mandatory=$True)][String] $Url,        [Parameter(Mandatory=$True)][String] $LocalFile )$client = New-Object System.Net.WebClient$client.DownloadFile($Url, $LocalFile)执行Get-Help 会出现下面效果，我们看到在上面书写的注释已经正确显示出来了，我们也可以用 get-help C:\\Download-File.ps1 -examples 去获取示例对这几个参数简单说明一下：  .SYNOPSIS 对命令的简要描述 .DESCRIPTION 对命令的详细描述.EXAMPLE 命令的使用范例，可以写多个范例.PARAMETER 对命令需要的参数做描述，可以对列举多个参数 .NOTE 除以上外还可以用NOTE写一些备注信息，NOTE信息只是做参考，不会在 Get-Help 时出现PS C:\\&gt; Get-Help .\\Download-File.ps1NAME    C:\\Download-File.ps1SYNOPSIS    Download a fileSYNTAX    C:\\Download-File.ps1 [-Url] &lt;String&gt; [-LocalFile] &lt;String&gt; [&lt;CommonParameters&gt;]DESCRIPTION    Download a file from internet, you must provided a valid url of the fileRELATED LINKSREMARKS    To see the examples, type: \"get-help C:\\Download-File.ps1 -examples\".    For more information, type: \"get-help C:\\Download-File.ps1 -detailed\".    For technical information, type: \"get-help C:\\Download-File.ps1 -full\".发布一个模块至此我们已经写好一个模块，但是是以单个脚本文件存在的，调用时需要输入路径，还是和内置的Cmdlet有些区别。 这时候我们可以借助PowerShell Module。将以上脚本封装到Function里，然后统一放到PowerShell Module里创建文件: MyModule.psm1，内容如下Function Download-File {    &lt;#    .SYNOPSIS        Download a file    .DESCRIPTION        Download a file from internet, you must provided a valid url of the file    .EXAMPLE         Download-File \"https://ss.bdimg.com/static/superman/img/logo/bd_logo1_31bdc765.png\" c:\\logo.png    .EXAMPLE         Download-File -Url \"https://ss.bdimg.com/static/superman/img/logo/bd_logo1_31bdc765.png\" -LocalFile c:\\logo.png    .PARAMETER Url        The Url information for the file to download    .PARAMETER LocalFile        The destination file will dave in local    #&gt;    param(            [Parameter(Mandatory=$True)][String] $Url,            [Parameter(Mandatory=$True)][String] $LocalFile     )    $client = New-Object System.Net.WebClient    $client.DownloadFile($Url, $LocalFile)}Export-ModuleMember \"*-*\"导入Module文件，我们看到PowerShell提示了一个Warning，原来是我们使用的动词不规范，Download并不在被认可的动词清单之中。PS C:\\&gt; Import-Module .\\MyModule.psm1WARNING: The names of some imported commands from the module 'MyModule' include unapproved verbs that might make themless discoverable. To find the commands with unapproved verbs, run the Import-Module command again with the Verboseparameter. For a list of approved verbs, type Get-Verb.PS C:\\&gt; Get-Command -Module MyModuleCommandType     Name                                               ModuleName-----------     ----                                               ----------Function        Download-File                                      MyModule使用 Get-Verb，选取一个合适的动词，如：Get-WebFile最后一步将多个Function封装到Module文件中，取一个合适的Module名字，再借助于GitHub，我们可以将自己的类库分享给更多的朋友使用啦在此我也安利一下我整理的PowerShell类库，存放在 https://github.com/cylin2000/powertask ,只需一句话调用即可使用，方便快捷iex (new-object net.webclient).downloadstring('https://raw.githubusercontent.com/cylin2000/powertask/master/PowerTask.ps1?t='+(Get-Random))参考资料https://blogs.msdn.microsoft.com/timid/2013/07/03/why-use-approved-verbs/https://msdn.microsoft.com/en-us/library/windows/desktop/ms714428(v=vs.85).aspxhttps://visualstudiogallery.msdn.microsoft.com/f017b10c-02b4-4d6d-9845-58a06545627f https://technet.microsoft.com/en-us/library/hh360993.aspx【全文完】"
  },
  
  {
    "title": "在线的PowerShell类库 - PowerTask",
    "url": "/2016/12/powertask/",
    "categories": "技术",
    "tags": "powershell",
    "date": "2016-12-01 19:37:45 +0800",
    





    
    "snippet": "在公司的项目中，写了大量的PowerShell脚本去安装软件和部署新的Release，偶尔也会分享PowerShell脚本给其他Team的同事。闲暇之余，研究了一下，发现只要打开权限，PowerShell也有远程下载执行脚本并且执行的功能，遂产生一个念头，如果将通用的PowerShell脚本封装成在线的功能库，然后本地只用一行脚本载入一下，这样不是能很好的复用了吗？ 而且可以实时载入最新的版...",
    "content": "在公司的项目中，写了大量的PowerShell脚本去安装软件和部署新的Release，偶尔也会分享PowerShell脚本给其他Team的同事。闲暇之余，研究了一下，发现只要打开权限，PowerShell也有远程下载执行脚本并且执行的功能，遂产生一个念头，如果将通用的PowerShell脚本封装成在线的功能库，然后本地只用一行脚本载入一下，这样不是能很好的复用了吗？ 而且可以实时载入最新的版本，那不是很快活。说干就干，在GitHub上面开了项目，暂且命名为 PowerTask，地址 https://github.com/cylin2000/powertask主要功能      用管理员模式打开PowerShell    如果你是第一次使用PowerShell，输入以下命令，打开脚本执行权限（执行一次即可，后面再打开不需要重复执行）    Set-ExecutionPolicy bypass        复制粘贴，执行以下命令    iex (new-object net.webclient).downloadstring('https://www.soft263.com/dev/PowerTask/PowerTask.ps1')# 或者iex (new-object net.webclient).downloadstring('https://raw.githubusercontent.com/cylin2000/powertask/master/PowerTask.ps1?t='+(Get-Random))        系统出现以下界面代表载入成功  获取使用帮助比如我们要使用 Get-StringHash , 这是个字符串加密工具，可以使用标准的powershell命令Get-Help Get-StringHash查询使用帮助执行 Get-StringHash 获得 MD5 编码PS C:\\Users\\ycai8&gt; Get-StringHash \"abc\"900150983cd24fb0d6963f7d28e17f72功能简介PowerTask 目前包含的功能还不是很多，但是在不断完善中，下面是一个简要的介绍Add-FtpFile            # 上传文件到FTP服务器Compress-Zip           # 压缩 Zip 文件Expand-Zip             # 解压 Zip 文件Get-DoubanMovieRate    # 获取电影的豆瓣评分(调用的豆瓣API)Get-FtpFile            # 下载FTP文件Get-InstalledSoftware  # 获取本地安装的软件清单Get-Software           # 下载在线软件Get-StringHash         # 获取文本的加密编码Get-WebContent         # 获取Web地址的文本内容，类似于 wgetGet-WebFile            # 下载Web地址的文件Install-PowerTask      # 安装PowerTask到本地Install-Software       # 安装在线软件Invoke-Batch           # 调用本地bat文件Invoke-FlashWindow     # 调用闪屏窗口Invoke-Sql             # 执行本地SQL脚本New-RandomPassword     # 生成一个随机密码Send-Sms               # 发送短信(使用webchinese接口)Set-TaskbarProgress    # 设置Taskbar进度条Show-BalloonTip        # 显示桌面右下角气泡提示【全文完】"
  },
  
  {
    "title": "基于REST的接口定义思考",
    "url": "/2016/08/rest-study/",
    "categories": "技术",
    "tags": "angular, rest",
    "date": "2016-08-08 17:01:10 +0800",
    





    
    "snippet": "因前后台分离，使用AngularJS作为纯前端，需要设计一组基于JSON的API，统一前后台的接口规范。该组API需要有如下特性:  统一接口调用风格  统一接口返回码  以尽可能简单的方式提供调用说明  接口支持增删改查等基本功能，也有其他自定义功能，如 软删除(IsDeleted = 1)调查首先想到的是REST，设计一套RESTful的方案，如 https://www.dummy.co...",
    "content": "因前后台分离，使用AngularJS作为纯前端，需要设计一组基于JSON的API，统一前后台的接口规范。该组API需要有如下特性:  统一接口调用风格  统一接口返回码  以尽可能简单的方式提供调用说明  接口支持增删改查等基本功能，也有其他自定义功能，如 软删除(IsDeleted = 1)调查首先想到的是REST，设计一套RESTful的方案，如 https://www.dummy.com/api/menu 提供最MENU的管理使用HTTP动词作为操作管理GET : 获取菜单POST : 创建菜单PUT : 创建或更新菜单DELETE : 删除菜单现实使用的时候发现如下问题：  GET 接口可以返回一个数据{menu} 或者一组数据[{menu},{menu},{menu}], 后台要单独处理      如 GET /menu 返回 一组[{menu},{menu},{menu}]  GET /menu/1 通过路由映射到后台 Menu(int id) 方法，返回一个menu  但是 如果我的查询条件中就有包含 {id:1} 这样的条件，那么会出现  GET /menu , post data {id:1}, 这样会自动路由到 Menu(int id) 方法，期望的是返回menu数组，其中包含一个menu [{menu}]，后台只返回了一个{menu}        按照wikipedia的举例，menu和menus是分开的  GET https://www.store.com/productsGET https://www.store.com/product/12345      REST推荐通过状态码返回出错信息    对于HTTP的状态吗，常规的我只记得          200 返回正常      401 认证错误      404 找不到页面      500 服务器错误      其他的只能现用现查，这样当后台返回409，我查完得知表示资源冲突，但是具体冲突是因为什么，还是需要和后台沟通好。另一个问题是，直观的感觉，返回200就代表正常，如果4xx，5xx就感觉是服务器错误，和我的应用程序无关才是，3xx基本没碰到过。但是这里409是我们自己后台抛出的，和服务器无关。我不希望将系统错误，传输错误和应用程序错误混为一谈。  只有四个动词，不够描述后台所有的操作，按照REST的推荐，应该都封装到PUT里而微信公众号的接口设计却没有完全使用这种方式https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKENhttps://api.weixin.qq.com/cgi-bin/menu/get?access_token=ACCESS_TOKENhttps://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN百度地图的API也是https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-placeapi  虽然HTTP的动作只有4个，但是后台为了操作明了，同样还是需要创建多个function来表示不同的操作内容，前台AngularJS同样需要创建多个function来表示动作  某些浏览器不支持PUT,DELETE等从此（这个问题现在好像不成问题了）安全按照微信API的方式，统一使用access_token，就是说每次请求都需要带入access_token，防止跨站攻击思考我一直想强行用REST的方法整理接口，因为这个标准存在了，与别人沟通的时候，公认约定总归好于个人约定但是使用过程中诸多不顺，因此查找文章以及知名开放API的提供者，比如微信公众号API终于找到了支撑自己的几个理由：  REST是设计风格而不是标准，这也是很多地方说RESTful的原因，既然是风格那也就是可以有选择的使用  微信的API设计，并不是完全的REST，他的动词都是放在资源的后面，这点结合后台api的function非常方便，微信API的使用频率和使用量应该可以打消我们其他的顾虑，比如效率，安全  SOAP也是一种WEB访问协议，他封装了操作，用XMLSpy访问SOAP的wsdl，可以得到可以操作的方法，只是使用方法复杂，我们为何不可把操作结合到REST风格的url里，这样既可知道调用方法，又不需通过复杂的方式取得结论找到了理由，自然要设计适合自己的API，而不是用REST就全部REST结论很简单，即使用REST那样清晰明了的URL风格，结合SOAP的动作的描述方式，对动作在URL进行描述。所有的返回都是200，应用程序错误用errcode表示接口只使用GET 和POST 两种动词 , 这样不存在浏览器兼容问题https://www.dummy.com/api/menu/get    表示获取菜单(单个记录)https://www.dummy.com/api/menu/query  表示查询菜单(多条记录)，post数据中加入查询条件https://www.dummy.com/api/menu/create 表示创建菜单https://www.dummy.com/api/menu/update 表示更新菜单https://www.dummy.com/api/menu/delete 表示删除菜单结合 AngularJS的 Resourceapp.controller('TableCtrl',function($scope, $routeParams, $resource) {    var User = $resource('/api/user/:_action',      {id:\"@id\"},       {        get:   {method:\"GET\",  params:{_action:\"get\"}},        query: {method:\"POST\", params:{_action:\"query\"}, isArray:true},        create:{method:\"POST\", params:{_action:\"create\"}},        update:{method:\"POST\", params:{_action:\"update\"}},        delete:{method:\"GET\",  params:{_action:\"delete\"}},      });    $scope.users = User.query({ticket:\"1155\"});    $scope.id = $routeParams.id;    if($scope.id){      $scope.user = User.get({id:$scope.id})    }});  不需要参数的，或者参数在URL中提供的使用GET方法    https://www.dummy.com/api/menu/get https://www.dummy.com/api/menu/get?id=5https://www.dummy.com/api/menu/delete?id=6        需要提交数据的使用POST方法https://www.dummy.com/api/menu/createPOST数据如下{    name:\"测试菜单\"}https://www.dummy.com/api/menu/update{    id:\"5\",    name:\"新菜单\"}  返回格式操作正确{    \"errcode\":0,    \"errmsg\":\"ok\"}操作错误{    \"errcode\": 401,    \"errmsg\":\"No Access\"}操作正确有数据{    \"errcode\":0,    \"errmsg\":\"ok\",    \"menu\":{        \"name\":\"测试菜单\"    }}https://www.dummy.com/api/menu/help 获取menu下的接口说明文档，以json返回，这样接口就可以像SOAP那样，自说明这个只是一个设想，需完善{    \"get\":{        \"http\":\"get\",        \"request\":{},        \"response\":{            \"errcode\":0,            \"errmsg\":\"ok\"        }    },    \"create\":{        \"request\":{        },        \"response\":{        }    }}参考文章https://zh.wikipedia.org/zh-cn/RESThttps://zh.wikipedia.org/zh-cn/SOAP https://www.infoq.com/cn/articles/rest-introductionhttps://mp.weixin.qq.com/wiki/10/0234e39a2025342c17a7d23595c6b40a.htmlhttps://mindhacks.cn/2009/01/16/hammers-and-nails/https://blog.csdn.net/pongba/article/details/3796771多年以后的后记后来又了解了很多这方面的内容，才知道了 Restful 和 Json RPC 之争，我上述的设计方法就试属于 Json RPC, 但是也是有缺点的，比如动词设置不规范，不遵守HTTP原生规则，导致调用方多出很多沟通成本，微信公众号的API也是被吐槽已久。关于设计 Restful 的API也是可以的，只是需要花更多的时间理清实体，比如 github 的 api, 其中做 migration https://docs.github.com/en/rest/reference/migrations  就是如下风格POST /orgs/{org}/migrations下载一个 mrgrationGET /orgs/{org}/migrations/{migration_id}/archive解锁一个 migration 的 repoDELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock并没有用到 migrate, lock 等动词关于优秀的API设计，可以参考如下 微软 和 Paypal 的 API Guidelinehttps://github.com/microsoft/api-guidelineshttps://github.com/paypal/api-standards/blob/master/api-style-guide.md【全文完】"
  },
  
  {
    "title": "AngularJS 动态加载的思考",
    "url": "/2016/07/angular-dynamic-loading/",
    "categories": "技术",
    "tags": "angular, javascript",
    "date": "2016-07-21 19:37:45 +0800",
    





    
    "snippet": "本文使用的AngularJS是基于1.x版本的。使用AngularJS做前端，路由都是静态配置的，久而久之发现每次新增加一个模块都要配置一下路由，实在有些麻烦，遂研究了一下能否动态配置路由信息现状项目中使用的是ui-router，因为要支持多级路由，所以没有使用默认的路由，代码如下angular.module('app').config(function ($stateProvider, $...",
    "content": "本文使用的AngularJS是基于1.x版本的。使用AngularJS做前端，路由都是静态配置的，久而久之发现每次新增加一个模块都要配置一下路由，实在有些麻烦，遂研究了一下能否动态配置路由信息现状项目中使用的是ui-router，因为要支持多级路由，所以没有使用默认的路由，代码如下angular.module('app').config(function ($stateProvider, $urlRouterProvider) {    $urlRouterProvider.otherwise(\"/login\");    $stateProvider        .state('home', {            url: '/home',            controller: 'homeController',            templateUrl: 'views/home.html'        })        .state('feature1', {            url: '/feature1',            controller: 'feature1Controller',            templateUrl: 'views/feature1.html'        })        .state('feature2', {            url: '/feature2',            controller: 'feature2Controller',            templateUrl: 'views/feature2.html'        })    });如此对 /home, /feature1, /feature2 这样的模块，每次增加一个就要做如下动作  添加state记录  state,url,controller,templateurl都按照约定写好，否则不容易直接找到  index.html 页面里要添加controller的js文件这样下来，当模块达到十几或几十个的时候，首页就是一串JS的文件引入，config里面state也是很多定义，关键是，任何一个地方写错一个字母，功能就直接没用了。解决开始尝试像后台MVC一样，比如#/home, 就动态载入 views/home.html 配合 controllers/home.js，后来发现state不配置还是很难的。退而求其次。预定义一个数组，然后按自定义规则加载var states = [\"home\",\"about\",\"about.company\",\"contact\"];然后根据名称，自动约定加载controller和view信息，关于controller的自动加载，使用了ocLazyLoad模块核心代码如下angular.module('app').config(function ($stateProvider, $urlRouterProvider) {    $urlRouterProvider.otherwise(\"/home\");    var states = [\"home\",\"about\",\"about.company\",\"contact\"];    angular.forEach(states, function(state) {        var controllerName = state.replace(/\\../g,function(m){            return m.replace(\".\",\"\").toUpperCase()}        );        var state_parts = state.split(\".\");        var controllerFile = state_parts[0];        var url = \"/\"+state_parts[state_parts.length - 1];        $stateProvider.state(state, {            url: url,             templateUrl: 'views/' + state + '.html',            controller: controllerName + 'Controller',            resolve: {                deps:['$ocLazyLoad', function($ocLazyLoad) {                    return $ocLazyLoad.load ([                        {                            name: 'controllers',                            files: [                                'js/controllers/'+controllerFile+'.js'                            ]                        }                    ])                }]            }        }) ;    })});使用此方法，还是不能像后端MVC那样自动解析，但是已经可以少些很多重复代码了。【全文完】"
  },
  
  {
    "title": "PowerShell小说爬虫",
    "url": "/2016/06/powershell-spider/",
    "categories": "技术",
    "tags": "powershell",
    "date": "2016-06-20 17:59:45 +0800",
    





    
    "snippet": "老婆最近迷上了网络小说，在线一张一张网页看的十分的累，而且广告不停弹出，非常烦人。我就赶紧发挥一把，写个简单的脚本把文件内容批量抓取下来，让她知道编程也是有点实际用处的。虽然知道Python在爬虫方面是个强项，但是暂时不是很熟悉，就先用 PowerShell 勉强实现一下，直接上代码：$url = \"https://m.d8qu.com/104/104936/12850949.html\"$o...",
    "content": "老婆最近迷上了网络小说，在线一张一张网页看的十分的累，而且广告不停弹出，非常烦人。我就赶紧发挥一把，写个简单的脚本把文件内容批量抓取下来，让她知道编程也是有点实际用处的。虽然知道Python在爬虫方面是个强项，但是暂时不是很熟悉，就先用 PowerShell 勉强实现一下，直接上代码：$url = \"https://m.d8qu.com/104/104936/12850949.html\"$out = \"c:\\novel.html\"$wc = New-Object System.Net.WebClient#$index = $wc.DownloadString($url)#$reg = [regex]'&lt;a href=\"(/read/31485/.*?)\".*?&gt;(.*?)&lt;/a&gt;'#$mm = $reg.Matches($index)$fullContent = \"\"for($i = 1 ; $i -le 614; $i++){    $chapterUrl = $url        $chapterContent = $wc.DownloadString($chapterUrl)    $chapterReg = [regex]'(?s)&lt;div id=\"nr1\".*?&gt;(.*?)&lt;/div&gt;' #(?s)表示多行/跨行匹配    $chapterMatch = $chapterReg.Matches($chapterContent)    $chapterText = $chapterMatch.Groups[1].Value    $titleReg = [regex]'(?s)&lt;div.*?id=\"nr_title\"&gt;(.*?)&lt;/div&gt;'    $titleMatch = $titleReg.Matches($chapterContent)    $chapterTitle = $titleMatch.Groups[1].Value    $nextReg = [regex]'&lt;a id=\"pb_next\" href=\"(.*?)\"&gt;下一章&lt;/a&gt;'    $nextMatch = $nextReg.Matches($chapterContent)    $nextUrl = $nextMatch.Groups[1].Value    $title = $chapterTitle.Trim()    Write-Host \"处理 $url $title\"    #Add-Content $out \"$chapterTitle &lt;br/&gt;\"    #Add-Content $out \"$chapterText &lt;br/&gt;&lt;br/&gt;\"    $fullContent = $fullContent+\"$chapterTitle &lt;br/&gt;\"    $fullContent = $fullContent+\"$chapterText &lt;br/&gt;&lt;br/&gt;\"    $url = \"https://m.d8qu.com$nextUrl\"}Add-Content $out $fullContent #一起写入，防止不停Add-Content出现文件占用错误【全文完】"
  },
  
  {
    "title": "Angular项目结构思考",
    "url": "/2016/05/angular-refactor/",
    "categories": "技术",
    "tags": "angular, javascript",
    "date": "2016-05-16 19:34:45 +0800",
    





    
    "snippet": "最近在重构项目组的两个前端项目，都是基于AngularJS(1.0版本)的，重构的过程中有些思考，在此记录下来备忘以及参考重构目的  创建公共的web前端项目，在启动其他类似项目的时候，可以最小修改的去使用  规范前端js代码，去除不必要的全局变量，统一命名风格  异常处理、日志记录、诊断、安全性和本地数据储藏等模块，许多地方都可以用，可以抽取到同一个地方约定命名  js/css/html ...",
    "content": "最近在重构项目组的两个前端项目，都是基于AngularJS(1.0版本)的，重构的过程中有些思考，在此记录下来备忘以及参考重构目的  创建公共的web前端项目，在启动其他类似项目的时候，可以最小修改的去使用  规范前端js代码，去除不必要的全局变量，统一命名风格  异常处理、日志记录、诊断、安全性和本地数据储藏等模块，许多地方都可以用，可以抽取到同一个地方约定命名  js/css/html 文件，如果有多个单词，用连字符-，如 jquery datagrid，则写作 jquery-datagird目录结构  按功能模块划分 按照它们代表的功能来给创建的文件夹命名，当文件夹包含的文件超过7个,就考虑新建文件夹为什么？  开发者可以快速定位代码，快速识别文件代表的意思，结构尽可能扁平  路由和controll对应关系可以很容易找到  如果按照类型划分功能，如当controller里文件很多时，在到对应view里找相应的文件，就会变得比较麻烦  路由和controller/view的对应关系，可以很容易找到一般目录网站目录结构web/    css/              #所有自定义样式，包括字体        reset.css     #重置浏览器样式        app.css       #应用程序自定义样式    img/              #所有自定义图片文件    js/               #所有自定义js脚本        app.js        #应用程序引导脚本    lib/              #所有第三方文件，每个目录表示一个第三方文件        angularjs     #引入angularjs类库        jquery        #引入jquery类库        bootstrap     #引入bootstrapAngularJs网页目录结构，按模块划分app/    css/    img/    js/        controllers/    #angular controller 定义，一般和view匹配        directives/     #angular directive定义        services/       #angular service定义        app.js          #app定义，定义这个app使用了多少其他模块        config.js       #app配置，定义路由信息    lib/                #第三方类库，同上    views/              #所有视图文件，独立出来是方便可以使用其他视图    为什么?  将views单独出来，可以较为容易的替换皮肤，因为js的逻辑可以不变  单独定义directive和service，因为这两块内容可以直接迁移到其他项目，如果做得很稳定，可以放到lib中  app.js/config.js 定义使用到的模块和路由信息，可以提供基础模块，使用到新项目是再自由添加和修改  controllers 一般新项目都会单独重写【全文完】"
  },
  
  {
    "title": "VIM 快速上手指南",
    "url": "/2014/07/vim-hand-book/",
    "categories": "技术",
    "tags": "vim, editor",
    "date": "2014-07-02 11:16:45 +0800",
    





    
    "snippet": "  VIM 是linux下一款优秀的编辑器，但是上手难度略大，网络上可以找到的教程很多，快捷键也非常多，一时很难记住。本文换一种思路，就是根据平时自己的常用需要，去反查VIM如何操作的，再记录下来，这样不常用的也不需要拿出来干扰。入门VIM和平常的编辑器有一个很大的不同，就是控制模式，当你使用 vim test.txt 进入编辑界面后，你会发现按什么键都不太起作用，然后也不知道怎么退出。进入...",
    "content": "  VIM 是linux下一款优秀的编辑器，但是上手难度略大，网络上可以找到的教程很多，快捷键也非常多，一时很难记住。本文换一种思路，就是根据平时自己的常用需要，去反查VIM如何操作的，再记录下来，这样不常用的也不需要拿出来干扰。入门VIM和平常的编辑器有一个很大的不同，就是控制模式，当你使用 vim test.txt 进入编辑界面后，你会发现按什么键都不太起作用，然后也不知道怎么退出。进入控制模式之后，按 i 键，就可以进入编辑模式，这时候就可以随便输入一些内容 然后按ESC键，又会回到控制模式，这时候按:键，会在屏幕最下面出现 : 提示符 接着输入 wq，就可以保存当前文件退出，或者 q! 放弃当前的内容退出。 至此就完成了最简单的打开文件，编辑文件，和保存退出的操作了，应急编辑一下配置文件应该足够了。下面记录一些使用场景，中文括号【】里面为助记词切换模式ESC : 回到控制模式控制模式下输入 :  切换到命令模式， 输入 :wq【write&amp;quit】 保存退出， :q! 放弃保存退出i【insert】: 切换到编辑模式  o 切换编辑模式，且在下方插入一个新行跳转gg : 跳转到第一行第一个字符G : 跳转到最后一行G$ : 跳转到最后一行最后一个字符0 : 跳转到当前行的第一个字符选择v : 在控制模式下按 v【visual】，再按光标键，可以选择区域复制y : 选择区域后，按 y 复制当前区域到缓冲区yy : 直接复制一整行nyy : n为数字，表示复制几行yG : 复制到文档最末尾现在实践一个常用操作，全选整个文本，拷贝内容。 操作如下gg 跳转到文件首 v 开启视图选择模式 G$ 跳转到文件尾， y 复制所有内容.剪切d : 选择区域后，按 d 剪切当前区域到缓冲区dd : 直接剪切当前行ndd : n为数字，表示剪切几行dG : 剪切到文档最末尾粘贴p【paste】 : 粘贴缓冲区内容到光标处撤销操作u : 如果想取消前面的步骤，按u【undo】，重做则是 ctrl+r【redo】查找/查找下一个vim 中用 / 和 ? 来查找字符串输入 / ，然后输入要查找的关键字，找到后，按回车继续 按 n 【next】查找下一个， N 查找上一个，找到后输入 i 开始编辑替换vim 中可以使用 :s 命令来替换字符串:s/vivian/sky/ 替换当前行第一个 vivian 为 sky:s/vivian/sky/g 替换当前行所有 vivian 为 sky:n，$s/vivian/sky/g 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky，其中n为数字，$表示最末行。xshell vim 小键盘乱码问题修改 session 属性 -&gt; 终端(Terminal) -&gt; VT模式(VT Modes) -&gt; 初始数字键盘模式(Initial Numeric Kepad Mode(DECNKM))选择 设置为普通(set to normal)VIM 常用快捷键一. 移动光标1. 左移h. 右移l. 下移j. 上移k2. 向下翻页ctrl + f，向上翻页ctrl + b3. 向下翻半页ctrl + d，向上翻半页ctrl + u4. 移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^5. 移动光标到下一个句子 ），移动光标到上一个句子（6. 移动到段首{，移动到段尾}7. 移动到下一个词w，移动到上一个词b8. 移动到文档开始gg，移动到文档结束G9. 移动到匹配的{}.().[]处%10. 跳到第n行 ngg 或 nG 或 :n11. 移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L12. 读取当前字符，并移动到本屏幕内下一次出现的地方 *13. 读取当前字符，并移动到本屏幕内上一次出现的地方 #二. 查找替换1. 光标向后查找关键字 #或者g#2. 光标向前查找关键字 *或者g*3. 当前行查找字符 fx， Fx， tx， Tx4. 基本替换 :s/s1/s2 （将下一个s1替换为s2）5. 全部替换 :%s/s1/s26. 只替换当前行 :s/s1/s2/g7. 替换某些行 :n1，n2 s/s1/s2/g8. 搜索模式为 /string，搜索下一处为n，搜索上一处为N9. 制定书签 mx， 但是看不到书签标记，而且只能用小写字母10. 移动到某标签处 `x，1旁边的键11. 移动到上次编辑文件的位置 `.PS：.代表一个任意字符 *代表一个或多个字符的重复         正则表达式的内容将会在后续文章中整理三. 编辑操作1. 光标后插入a， 行尾插入A2. 后插一行插入o，前插一行插入O3. 删除字符插入s， 删除正行插入S4. 光标前插入i，行首插入I5. 删除一行dd，删除后进入插入模式cc或者S6. 删除一个单词dw，删除一个单词进入插入模式cw7. 删除一个字符x或者dl，删除一个字符进入插入模式s或者cl8. 粘贴p，交换两个字符xp，交换两行ddp9. 复制y，复制一行yy10. 撤销u，重做ctrl + r，重复.11. 智能提示 ctrl + n 或者 ctrl + p12. 删除motion跨过的字符，删除并进入插入模式 c{motion}13. 删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx14. 删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx15. 删除motion跨过的字符，删除但不进入插入模式 d{motion}16. 删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx17. 删除当前字符到下一个字符处的所有字符，包括x字符 dfx18. 如果只是复制的情况时，将12-17条中的c或d改为y19. 删除到行尾可以使用D或C20. 拷贝当前行 yy或者Y21. 删除当前字符 x22. 粘贴 p23. 可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy24. 重复执行上一个作用使用.25. 使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行26. 在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进27.  &gt;&gt; 缩进所有选择的代码28.  &lt;&lt; 反缩进所有选择的代码29. gd 移动到光标所处的函数或变量的定义处30. K 在man里搜索光标所在的词31. 合并两行 J32. 若不想保存文件，而重新打开 :e!33. 若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换四. 窗口操作1. 分隔一个窗口:split或者:vsplit2. 创建一个窗口:new或者:vnew3. 在新窗口打开文件:sf {filename}4. 关闭当前窗口:close5. 仅保留当前窗口:only6. 到左边窗口 ctrl + w， h7. 到右边窗口 ctrl + w， l8. 到上边窗口 ctrl + w， k9. 到下边窗口 ctrl + w， j10. 到顶部窗口 ctrl + w， t11. 到底部窗口 ctrl + w， b五. 宏操作1. 开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中2. @[a-z]执行寄存器[a-z]中的操作3. @@执行最近一次记录的宏操作六. 可视操作1. 进入块可视模式 ctrl + v2. 进入字符可视模式 v3. 进入行可视模式 V4. 删除选定的块 d5. 删除选定的块然后进入插入模式 c6. 在选中的块同是插入相同的字符 I&lt;String&gt;ESC七. 跳到声明1. [[ 向前跳到顶格第一个{  2. [] 向前跳到顶格第一个}3. ]] 向后跳到顶格的第一个{4. ]] 向后跳到顶格的第一个}5. [{ 跳到本代码块的开头6. ]} 跳到本代码块的结尾八. 挂起操作1. 挂起Vim ctrl + z 或者 :suspend2. 查看任务 在shell中输入 jobs3. 恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）4. 执行shell命令 :!command5. 开启shell命令 :shell，退出该shell exit6. 保存vim状态 :mksession name.vim7. 恢复vim状态 :source name.vim8. 启动vim时恢复状态 vim -S name.vim【全文完】"
  },
  
  {
    "title": "Todo 软件使用小结",
    "url": "/2014/06/todo-practice/",
    "categories": "随笔",
    "tags": "todo, growth",
    "date": "2014-06-24 22:04:01 +0800",
    





    
    "snippet": "今年初读完了Get Things Done(中译本：尽管去做，无压的工作艺术)，也想实践一把GTD，陆陆续续的试用了很多GTD相关的软件，有重量级的如Omni Focus，也有简单的todolist，简要记录各个软件的使用心得如下。因为刚买了iPad mini 所以大部分尝试的都是iOS的软件，其实很多软件也都有Android版本。  GoTasksiOS和Android下都有版本，界面简洁...",
    "content": "今年初读完了Get Things Done(中译本：尽管去做，无压的工作艺术)，也想实践一把GTD，陆陆续续的试用了很多GTD相关的软件，有重量级的如Omni Focus，也有简单的todolist，简要记录各个软件的使用心得如下。因为刚买了iPad mini 所以大部分尝试的都是iOS的软件，其实很多软件也都有Android版本。  GoTasksiOS和Android下都有版本，界面简洁，免费，可以和Google Tasks同步，支持无限级子任务。缺点是同步速度慢，有时候认证会丢失，需要重复输入密码，Google提供的Web端管理功能很弱  Wunderlist全平台支持，几乎所有的平台都有版本，免费版本可以随时同步，界面简洁，任务无上限，支持循环提醒，子任务等这个我使用时间还较长，中间放弃过一段时间去试用其他软件，缺点比如，已完成的任务不能再编辑，名称，详情，排序都不可以  Remember The Milk试用时间不长，多平台，感觉免费版限制较多  MyLifeOrganized多平台，提供目标管理视图和任务视图，让你可以做规划，也可以只关注当前要做的任务  Doit.im多平台，应该是蛮符合GTD理念的，界面简洁，免费版只能24小时同步一次（很多人因为这个原因放弃了它），收费版100元每年  TodoList强大的软件，开源，只有Windows版本，Android有个人用户开发的插件，任务的自定义属性很强大，基本没有你想不到的缺点是只有Windows平台，现在移动应用满天飞，没移动平台真不方便，另外界面也是很标准的GridView方式，没啥美感  TickTick国产软件，iOS Android 网页端都有版本，免费版可以同步，有任务条数限制，项目个数限制，不过基本够用，貌似主打海外市场  Omni Focus重量级GTD软件，看到很多文章介绍，GTD神器，价格相对较贵，只是在越狱的ipad上试了试，按照教程实施了几把，应该是视图功能用好了才能发挥它的强大，不过感觉对我来说，不需要这么强大的功能，所以就没有继续下去经过一段试用之后，发现自己已经陷入了工具选择困难中，每个工具中都有一些半拉子任务。这样就不是在实施GTD了，所以经过慎重考虑了下，只选用一种最后决定使用Wunderlist来管理自己的待办事项，原因如下:  免费，因为暂时对收费软件的使用还没有形成习惯，况且这个免费的做的真心不错  多平台支持，目前有Android手机，iPad mini平板，家用PC，公司PC，MacBook Pro各一部，能在这所有平台都同步非常方便  简单的使用方式 收件箱+自定义文件夹(目前我定义的为 目标/工作/私人/购物 等几个分类)  界面简洁，能设置任务多种重复方式  没有最好的工具，只有适合自己的工具，选一款适合你的工具，开始GTD吧。【后记】Wonderlist 已经被微软收购，现在叫 Microsoft To Do【全文完】"
  },
  
  {
    "title": "打造个人本地云",
    "url": "/2014/06/personal-cloud/",
    "categories": "随笔",
    "tags": "cloud",
    "date": "2014-06-17 19:16:45 +0800",
    





    
    "snippet": "这里说的云不是去申请服务器架设自己的云，而是利用现有的免费同步网盘来打造一个自己的云存储。现在每个人的设备都很多，至少是公司一台电脑，家里一台电脑，还有自己的手机端，平板等，这样数据的同步就显得比较重要网盘大战时，我也申请了很多网盘在用来整理存放自己的文件，当然不可能把所有文件每个网盘都放一份，下面是我的一些整理：  SkyDrive 这个是用的最久的同步盘，从Live Mesh时就开始用，...",
    "content": "这里说的云不是去申请服务器架设自己的云，而是利用现有的免费同步网盘来打造一个自己的云存储。现在每个人的设备都很多，至少是公司一台电脑，家里一台电脑，还有自己的手机端，平板等，这样数据的同步就显得比较重要网盘大战时，我也申请了很多网盘在用来整理存放自己的文件，当然不可能把所有文件每个网盘都放一份，下面是我的一些整理：  SkyDrive 这个是用的最久的同步盘，从Live Mesh时就开始用，主要同步工作的数据，就是国内同步速度实在是太慢了，现在不得已只好放弃  百度云 主要用于存放电影电视剧资源，不会同步到本地，原因其一是很多资源用百度网盘共享的，其二是百度云TV版在电视上播放很方便，不过最近限速搞得人很累  360云盘 当初是网盘大战是看到容量大申请的，后来发现同步盘速度很快，而且集成在浏览器的工具栏使用很方便，用来同步个人照片和视频数据，SkyDrive中的工作数据因为同步实在太慢，也迁移过来360云盘来  新浪V盘，主要用于存放电子书，其共享的搜索功能很好，有很多电子书 (2016年6月关闭)  有道云笔记 不是网盘，主要用于记录整理文档，也是因为OneNote同步太慢转过来的目前360云盘的目录分布如下，供参考  Dev 开发的代码，使用git本地版本库，这样版本库也会同步到其他机器上，可以随时查看历史，而且还不用到网络上申请git空间  备份 主要备份不常用的数据，用压缩包存储  个人 个人数据比如证件什么的  视频 手机或相机拍摄的视频内容  图片 手机或相机拍摄的照片  软件 常用软件，只放绿色软件，这样同步到其他机器可以直接使用  临时 存放临时文件【全文完】"
  },
  
  {
    "title": "MacBook Pro 使用小结",
    "url": "/2014/06/macbook-pro/",
    "categories": "随笔",
    "tags": "macbook",
    "date": "2014-06-14 17:15:15 +0800",
    





    
    "snippet": "买了个 MacBook Pro，到手已经一段时间，把玩之余，写点使用心得如下：配置  13英寸Retina显示屏  2.4G英特尔i5处理器  8G内存  256G闪存硬盘做开发是可以了，玩游戏是肯定不行使用心得  轻薄，虽然是 MacBook Pro 比 Air 要重，但是整体还是感觉很轻便的，放到背包里感觉不到什么重量  Retina屏幕很爽，早在买之前先去实体店试用了几把，想买轻便的M...",
    "content": "买了个 MacBook Pro，到手已经一段时间，把玩之余，写点使用心得如下：配置  13英寸Retina显示屏  2.4G英特尔i5处理器  8G内存  256G闪存硬盘做开发是可以了，玩游戏是肯定不行使用心得  轻薄，虽然是 MacBook Pro 比 Air 要重，但是整体还是感觉很轻便的，放到背包里感觉不到什么重量  Retina屏幕很爽，早在买之前先去实体店试用了几把，想买轻便的MacBook Air，最终还是被Retina屏幕折服  触摸板很强大，可以双指滚动，捏合放大缩小，三指切换应用屏幕等，操作习惯与iOS类似，操作简单方便，几乎可以不用鼠标，但是用久了手还是有点酸  Finder类似Windows的资源管理器，但是没有地址栏，略有不便  快捷键多以Command键组合其他，Command键在键盘上的位置略有不习惯  登录apple id之后，iPad上的内容比如记事本，日历，提醒，电话簿等会自动同步过来，比较方便  软件安装卸载比较方便，安装一般是将解压的app拖到Applications文件夹（一般发布的软件都会提供Applications的快捷方式），卸载也就是在将Applications的图标拖到废纸篓就可以  耗电少，用完直接扣上屏幕就可以，再打开屏幕时，直接可以使用，连续1个月不关机，没有什么运行慢的感觉安装的常用软件  搜狗输入法  Parallels Desktop 9  Xcode  Wunderlist  Sublime Text常用设置      Mac OS 10.9 默认排序方式是将中文排在英文前面的，设置方法为 “设置”-“语言和地区”-“列表排序顺序” 修改为 “中文简体GB2312排序”        Mac OS 10.9 默认文件夹和文件是一起排序的，没有像Win那样将文件夹排在前面，可以下载XtraFinder，然后设置“文件夹排在前面”选项        打开finder后，我们可以看到文件夹都在左侧的边栏中，有一些是我们经常要访问的文件夹，如果我们希望更快的进入，可以按住Cmd键，点按住文件夹，把它拖动到上面的工具栏中，当看到绿色加号后，松手，常用的文件夹就会被放到工具栏中，这时我们就可以点击它，更快的访问这个文件夹！  【全文完】"
  },
  
  {
    "title": "分享几个.NET写的小工具",
    "url": "/2014/06/personal-tools/",
    "categories": "技术",
    "tags": "xslt, regex",
    "date": "2014-06-09 19:06:45 +0800",
    





    
    "snippet": "整理下之前写的几个小工具  ForceXslt XSLT 测试工具  ForceRegex 正则表达式测试工具  ForceEmail 邮件发送模板工具ForceXsltForceXslt是我是用C#编写的Xslt测试工具，它可以让你专注于测试某段Xpath或者XSLT的template是否有效，而不需要一遍一遍的运行整个程序去检查某段xslt是否正确。工具提供了常用的模板，你可以选择模板，...",
    "content": "整理下之前写的几个小工具  ForceXslt XSLT 测试工具  ForceRegex 正则表达式测试工具  ForceEmail 邮件发送模板工具ForceXsltForceXslt是我是用C#编写的Xslt测试工具，它可以让你专注于测试某段Xpath或者XSLT的template是否有效，而不需要一遍一遍的运行整个程序去检查某段xslt是否正确。工具提供了常用的模板，你可以选择模板，改模板达内容到测试XSLT代码的效果。下载地址：https://www.caiyunlin.com/dev/ForceXslt/ForceXslt.exeForceRegexForceRegex是我使用C#编写的正则表达式测试工具，可以让你专注于测试某段正则表达式是否有效，而不用在VS的调试器里面单步调试去测试正则表达式。当初写这个工具是给自己练练手，另外自己的用着顺手，一旦有啥问题还可以改改。网上类似的工具很多，可以参考 https://regex101.com/下载地址：https://www.caiyunlin.com/dev/ForceRegex/ForceRegex.exeForceEmailForceEmail是我使用C#编写的邮件模板测试工具，这个小程序可以让你预先定义好邮件模板和替换符号这样在你再次发送类似邮件的时候，只需要编写占位符的地方，然后点击发送即可调出邮件发送程序。模板内容可以自己定义，具体的参数会自动生成到界面上去。下载地址：https://www.caiyunlin.com/dev/ForceEmail/ForceEmail.exe后记工具使用 Force 作为前缀，一是源于星球大战 May the Force be with you, 而是我参加工作参与的第一个内部项目名称叫 Force，特此纪念。【全文完】"
  }
  
]

