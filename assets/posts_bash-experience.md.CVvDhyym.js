import{_ as i,c as a,o as n,ah as l}from"./chunks/framework.ytAaTfF9.js";const c=JSON.parse('{"title":"Bash 踩坑指南","description":"在 AWS 平台自动化部署中编写 Bash 脚本的实战经验总结，详细介绍 Shell 的种类、不同解释器的区别以及常见的脚本编写陷阱和解决方案","frontmatter":{"title":"Bash 踩坑指南","date":"2020-04-07T00:00:00.000Z","category":"技术","tags":["bash","shell"],"urlname":"bash-experience","url":"https://www.caiyunlin.com/posts/bash-experience/","description":"在 AWS 平台自动化部署中编写 Bash 脚本的实战经验总结，详细介绍 Shell 的种类、不同解释器的区别以及常见的脚本编写陷阱和解决方案"},"headers":[],"relativePath":"posts/bash-experience.md","filePath":"posts/bash-experience.md"}'),h={name:"posts/bash-experience.md"};function e(p,s,t,k,d,o){return n(),a("div",null,[...s[0]||(s[0]=[l(`<blockquote><p>最近项目逐步迁移到AWS平台上，相关的代码管理和自动化部署也由TFS迁移到GitHub+Jenkins方案上，为此写了不少的bash脚本用来自动化部署和测试，也踩了相当多的坑，在此总结一下。</p></blockquote><h2 id="shell的种类" tabindex="-1">Shell的种类 <a class="header-anchor" href="#shell的种类" aria-label="Permalink to &quot;Shell的种类&quot;">​</a></h2><p>和Windows平台不一样，在Linux系统下，有多种Shell，所以同样的脚本，不同的解释器执行结果可能是不一样的，下面列举了常见的Shell种类。</p><ul><li>sh : sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了，是第一个流行的shell</li><li>bash : Bourne-Again SHell</li><li>dash ： theDebian Almquist Shell， Ubuntu的/bin/sh默认链接到dash</li><li>csh, tcsh, zsh, oh-my-zsh</li><li>busybox : 小巧的工具套件，1M大小，集成了上百个内置命令</li></ul><p>其中Bash是使用比较广泛的一种，大部分Linux系统的默认登陆Shell就是Bash，市面上大部分脚本也是Bash脚本。</p><p>如何查看当前系统支持的shell呢，执行<code>cat /etc/shells</code></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/shells</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># /etc/shells: valid login shells</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/bin/sh</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/bin/bash</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/bin/rbash</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/bin/dash</span></span></code></pre></div><p>下面几种方法可以查询当前使用的Shell相关信息</p><ol><li><code>ps -p $$</code> – 查询你当前正在使用的Shell</li><li><code>echo &quot;$SHELL&quot;</code> – 查询当前用户的默认Shell，但是不一定是你正在使用的Shell，比如你默认的shell是/bin/bash，但是你切换到了dash模式下，用这个命令查看，他的返回还是 /bin/bash</li><li><code>echo $0</code> – 另一个比较可靠的方法查询当前的Shell，你现在使用的是什么Shell就返回什么</li><li><code>ls -al /bin/sh</code> - 检查默认 sh 的解释器是哪个。 比如 sh 指向的是 dash, 那使用 sh xxx.sh 就相当于 dash xxx.sh</li></ol><p>在Jenkins里面，常常使用Docker构建一个Shell执行环境，所以根据你使用的Docker镜像不同，默认使用的Shell也不同，你可以使用上面的命令去测试当前的SHELL种类。</p><p>Shell不同，对命令的支持力度也不同，这里列举几个简单的Bash和Dash区别。</p><ol><li>Bash 支持 <code>function</code> 关键字 , Dash 不支持</li><li>Bash 支持快速大小写转换, Dash 不支持</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">str</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">str2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;WORLD&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> \${str^^}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> \${str2,,}</span></span></code></pre></div><ol start="3"><li>Bash 支持 <code>&lt;&lt;&lt;</code> 重定向, Dash 不支持</li></ol><h2 id="shell的交互方式" tabindex="-1">Shell的交互方式 <a class="header-anchor" href="#shell的交互方式" aria-label="Permalink to &quot;Shell的交互方式&quot;">​</a></h2><ul><li><p>login shell login shell 是你登陆到系统里是的默认shell，不管是通过终端或者通过SSH来连接，login shell会默认加载下面的文件，如果文件存在的话 <code>.profile</code>,<code>.bash_profile</code>,<code>.bash_login</code></p></li><li><p>interactive shell interactive shell 是当你在shell里面了，你输入了另外一个shell的名字，比如 <code>bash</code> 或者 <code>dash</code>, 你就进入了交互式shell环境，此时也会加载默认配置，比如 bash shell 会自动 <code>.bashrc</code> 所以，你可以把相关预定义配置放到这个文件里面，下面的命令可以测试已经开启的shell,使用exit可以退出交互式Shell</p></li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bash</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dash</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span></span></code></pre></div><ul><li>non-interactive shell non-interactive shell 是一个用户无法交互的Shell，一般都是用来执行自动化脚本. Jeknins 就是在使用 non-interactive shell.</li></ul><p>比如Ubuntu系统，当你登录了系统是，默认的登陆Shell是<code>bash</code>, 但是当你在Jenkins使用Ubuntu作为Docker镜像时，默认的Shell是 non-interactive shell, 他指向的是 <code>dash</code>, 如果我们使用的是基于 alpine 的linux，那么默认的 non-interactive shell 可能是 <code>busybox</code></p><h2 id="shell的执行类型" tabindex="-1">Shell的执行类型 <a class="header-anchor" href="#shell的执行类型" aria-label="Permalink to &quot;Shell的执行类型&quot;">​</a></h2><ul><li>fork <code>fork</code> 模式会复制当前进程信息并且创建一个副本进程，把副本进程作为当前进程的Child. 用下面的内容创建文件 <code>fork-test.sh</code> 来测试一下fork</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;fork-test.sh start&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;fork-test.sh end&quot;</span></span></code></pre></div><p>用下面文件调用 <code>fork-test.sh</code>, 执行之前可以先调用 <code>ps</code> 查看当前进程，然后执行后再观察当前进程，你会发现 fork-test会创建新的bash进程，然后执行完毕之后，又自动销毁掉。 进程中产生的环境变量等信息会一起销毁掉。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chmod</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 777</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./fork-test.sh</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./fork-test.sh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># or </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bash</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fork-test.sh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span></span></code></pre></div><ul><li>source</li></ul><p><code>source</code> 会在当前进程中直接执行脚本，不会创建新的子进程。 使用下面的脚本测试，然后观察进程，你会发现没有新的进程产生，然后注意使用source不需要为脚本文件指定执行权限。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">source</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fork-test.sh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># or</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fork-test.sh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span></span></code></pre></div><ul><li>exec</li></ul><p><code>exec</code> 和 <code>source</code>是一样的，不会产生新的子进程，但是它有个不一样的是，他执行被调用的脚本之后，会退出之前的脚本环境，所以当被调用脚本执行完毕退出之后，你会发现当前的shell也退出了。这个使用场景比较少，一半不经常使用。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exec</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./fork-test.sh</span></span></code></pre></div><h2 id="环境变量" tabindex="-1">环境变量 <a class="header-anchor" href="#环境变量" aria-label="Permalink to &quot;环境变量&quot;">​</a></h2><p>加入我们在Jenkins里面定义了一个环境变量, 比如 <code>DEPLOY_ENV=SB</code>, 在Bash中如何使用呢？</p><ol><li>不管是 <code>fork</code> 还是 <code>source</code> 来调用脚本，都可以直接使用上层定义的环境变量, 但是使用 <code>fork</code>的话，你没有办法修改变量并且将它返回到调用的地方。 用下面的脚本可以测试</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DEPLOY_ENV</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;SB&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># create env-test-sb.sh with following lines</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;DEPLOY_ENV is </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$DEPLOY_ENV</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># create env-test-dev.sh with following lines</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;UPDATE DEPLOY_ENV to DEV&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DEPLOY_ENV</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;DEV&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;DEPLOY_ENV is </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$DEPLOY_ENV</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bash</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> env-test-sb.sh</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bash</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> env-test-dev.sh</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;DEPLOY_ENV is </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$DEPLOY_ENV</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span></code></pre></div><ol start="2"><li>如果我们期望能改变环境变量，那必须要使用 <code>source</code></li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> env-test-dev.sh</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;DEPLOY_ENV is </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$DEPLOY_ENV</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span></code></pre></div><h2 id="在jenkins中如何用好bash" tabindex="-1">在Jenkins中如何用好Bash <a class="header-anchor" href="#在jenkins中如何用好bash" aria-label="Permalink to &quot;在Jenkins中如何用好Bash&quot;">​</a></h2><ol><li>在每一个sh脚本上面写上 <code>#!/bin/bash</code>， 这样脚本默认使用bash来解释执行</li><li>在Jenkins的sh代码块中，显示的使用bash命令来调用脚本，比如</li></ol><div class="language-groovy vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">groovy</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sh </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;&#39;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        echo &#39;Executing Deploy in SandBox&#39;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        bash ./deploy.sh</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        rc=$?; if [[ $rc != 0 ]]; then exit 1; else echo &quot;deploy completed&quot;; fi</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;&#39;&#39;</span></span></code></pre></div><p>因为bash会自动fork一个新的进程去执行实际脚本，所以最后必须拦截处理脚本的返回信息，这样有错误可以再提交到Jenkins中显示出来。</p><ol start="3"><li>在 deploy.sh 脚本中，再次调用其他脚本时，可以使用 source 方式，这样可以共享处理环境变量。</li></ol><h2 id="注意空格写法" tabindex="-1">注意空格写法 <a class="header-anchor" href="#注意空格写法" aria-label="Permalink to &quot;注意空格写法&quot;">​</a></h2><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 赋值正确写法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 错误写法</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># if 和条件语句块之间必须要有空格,[] 里面两端也必须要有空格</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">10</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">20</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ \${a} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-eq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> \${b} ]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;相等&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;不等&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fi</span></span></code></pre></div><h2 id="快速检查变量" tabindex="-1">快速检查变量 <a class="header-anchor" href="#快速检查变量" aria-label="Permalink to &quot;快速检查变量&quot;">​</a></h2><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AWS_ACCESS_KEY_ID</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;AWS_ACCESS_KEY_ID environment variable not defined&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[ $AWS_STAGE_NAME </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;none&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;exit because aws stage name is none&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 数值比较用下面表达式</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-eq</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ne</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -gt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -lt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ge</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -le</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 字符串比较用下面表达式  </span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> !=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -z</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span></span></code></pre></div><h2 id="使用函数" tabindex="-1">使用函数 <a class="header-anchor" href="#使用函数" aria-label="Permalink to &quot;使用函数&quot;">​</a></h2><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># create hello.sh</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#! /bin/bash</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sayhello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello,World&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello.sh</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayhello</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$?</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $result</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 函数只能返回 0 到 255 的数值，所以如果想返回字符串的话，需要使用点小技巧绕一下。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 我们可以使用 echo 字符串的方式，输出字符串，然后调用的地方使用\`$()\`包裹得到需要的信息。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    str</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">date</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;+%Y-%m-%d %H:%M:%S&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $str</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Invoke function</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $n</span></span></code></pre></div><p>我们也可以使用 <code>$()</code> 去调用其他脚本，比如 <code>$(node xxx.js)</code> 或者 <code>$(python xxx.py)</code> ， 这样可以使用其他的脚本去实现更强的功能，然后返回结果到bash中去。</p><p>【全文完】</p>`,49)])])}const g=i(h,[["render",e]]);export{c as __pageData,g as default};
